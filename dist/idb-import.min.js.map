{"version":3,"sources":["../src/idb-import.js"],"names":["stringify","JSON","obj","prop","Object","prototype","hasOwnProperty","call","a","b","_possibleConstructorReturn","this","getPrototypeOf","IdbImport","isNUL","schema","_typeof","mergePatch","Error","addEarlyCallback","e","db","target","result","transaction","_this2","_deleteAllUnused","cb","store","objectStore","storeName","Array","from","indexNames","forEach","indexName","exceptionIndexes","hasOwn","_this3","delIndex","clearUnusedStores","clearUnusedIndexes","objectStoreNames","keys","some","key","moveFrom","copyFrom","includes","_this4","delStore","_deleteIndexes","indexes","value","setCanonicalProps","storeProp","canonicalPropValue","newStore","replace","storeParams","contains","getStore","every","compareStringified","err","message","copyStore","renameStore","addStore","indexProp","newIndex","indexParams","oldIndex","index","_this5","addIndex","keyPath","_setup","schemaObj","_this6","_ret2","v","indexObj","_createIndex","arguments","length","undefined","_createStoreIfNotSame5","_this7","createPatches","schemaType","mixedObj","_this8","createIdbSchemaPatchSchema","createMergePatchSchema","createWholePatchSchema","schemas","sort","schemaVersion","version","parseInt"],"mappings":"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","file":"idb-import.min.js","sourcesContent":["/*\r\n# Notes\r\n\r\n1. Could use/adapt [jtlt](https://github.com/brettz9/jtlt/) for changing JSON data\r\n\r\n# Possible to-dos\r\n\r\n1. Support data within adapted JSON Merge Patch\r\n1. Allow JSON Schema to be specified during import (and export): https://github.com/aaronpowell/db.js/issues/181\r\n1. JSON format above database level to allow for deleting or moving/copying of whole databases\r\n1. `copyFrom`/`moveFrom` for indexes\r\n*/\r\n\r\nself._babelPolyfill = false; // Need by Phantom in avoiding duplicate babel polyfill error\r\nimport IdbSchema from 'idb-schema';\r\n\r\nconst stringify = JSON.stringify;\r\nconst hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\r\nconst compareStringified = (a, b) => stringify(a) === stringify(b);\r\n\r\nexport default class IdbImport extends IdbSchema {\r\n    constructor () {\r\n        super();\r\n    }\r\n    _setup (schema, cb, mergePatch) {\r\n        const isNUL = schema === '\\0';\r\n        if (!schema || typeof schema !== 'object' && !(mergePatch && isNUL)) {\r\n            throw new Error('Bad schema object');\r\n        }\r\n        this.addEarlyCallback((e) => {\r\n            const db = e.target.result;\r\n            const transaction = e.target.transaction;\r\n            if (mergePatch && isNUL) {\r\n                this._deleteAllUnused(db, transaction, {}, true);\r\n                return;\r\n            }\r\n            return cb(e, db, transaction);\r\n        });\r\n    }\r\n    _deleteIndexes (transaction, storeName, exceptionIndexes) {\r\n        const store = transaction.objectStore(storeName); // Shouldn't throw\r\n        Array.from(store.indexNames).forEach((indexName) => {\r\n            if (!exceptionIndexes || !hasOwn(exceptionIndexes, indexName)) {\r\n                this.delIndex(indexName);\r\n            }\r\n        });\r\n    }\r\n    _deleteAllUnused (db, transaction, schema, clearUnusedStores, clearUnusedIndexes) {\r\n        if (clearUnusedStores || clearUnusedIndexes) {\r\n            Array.from(db.objectStoreNames).forEach((storeName) => {\r\n                if (clearUnusedStores && !hasOwn(schema, storeName)) {\r\n                    // Errors for which we are not concerned and why:\r\n                    // `InvalidStateError` - We are in the upgrade transaction.\r\n                    // `TransactionInactiveError` (as by the upgrade having already\r\n                    //      completed or somehow aborting) - since we've just started and\r\n                    //      should be without risk in this loop\r\n                    // `NotFoundError` - since we are iterating the dynamically updated\r\n                    //      `objectStoreNames`\r\n                    // this._versions[version].dropStores.push({name: storeName});\r\n                    // Avoid deleting if going to delete in a move/copy\r\n                    if (!Object.keys(schema).some((key) => [schema[key].moveFrom, schema[key].copyFrom].includes(storeName))) {\r\n                        this.delStore(storeName); // Shouldn't throw // Keep this and delete previous line if this PR is accepted: https://github.com/treojs/idb-schema/pull/14\r\n                    }\r\n                } else if (clearUnusedIndexes) {\r\n                    this._deleteIndexes(transaction, storeName, schema[storeName].indexes);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    _createStoreIfNotSame (db, transaction, schema, storeName, mergePatch) {\r\n        const newStore = schema[storeName];\r\n        let store;\r\n        let storeParams = {};\r\n        function setCanonicalProps (storeProp) {\r\n            let canonicalPropValue;\r\n            if (hasOwn(newStore, 'key')) { // Support old approach of db.js\r\n                canonicalPropValue = newStore.key[storeProp];\r\n            } else if (hasOwn(newStore, storeProp)) {\r\n                canonicalPropValue = newStore[storeProp];\r\n            } else {\r\n                canonicalPropValue = storeProp === 'keyPath' ? null : false;\r\n            }\r\n            if (mergePatch && typeof canonicalPropValue === 'string') {\r\n                if (canonicalPropValue === '\\0') {\r\n                    canonicalPropValue = storeProp === 'keyPath' ? null : false;\r\n                } else {\r\n                    canonicalPropValue = canonicalPropValue.replace(/^\\0/, ''); // Remove escape if present\r\n                }\r\n            }\r\n            storeParams[storeProp] = canonicalPropValue;\r\n        }\r\n        const copyFrom = newStore.copyFrom;\r\n        const moveFrom = newStore.moveFrom;\r\n        try {\r\n            ['keyPath', 'autoIncrement'].forEach(setCanonicalProps);\r\n            if (!db.objectStoreNames.contains(storeName)) {\r\n                throw new Error('goto catch to build store');\r\n            }\r\n            store = transaction.objectStore(storeName); // Shouldn't throw\r\n            this.getStore(store);\r\n            if (!['keyPath', 'autoIncrement'].every((storeProp) => {\r\n                return compareStringified(storeParams[storeProp], store[storeProp]);\r\n            })) {\r\n                // Avoid deleting if going to delete in a move/copy\r\n                if (!copyFrom && !moveFrom) this.delStore(storeName);\r\n                throw new Error('goto catch to build store');\r\n            }\r\n        } catch (err) {\r\n            if (err.message !== 'goto catch to build store') {\r\n                throw err;\r\n            }\r\n            if (copyFrom) {\r\n                this.copyStore(copyFrom, storeName, storeParams); // May throw\r\n            } else if (moveFrom) {\r\n                this.renameStore(moveFrom, storeName, storeParams); // May throw\r\n            } else {\r\n                // Errors for which we are not concerned and why:\r\n                // `InvalidStateError` - We are in the upgrade transaction.\r\n                // `ConstraintError` - We are just starting (and probably never too large anyways) for a key generator.\r\n                // `ConstraintError` - The above condition should prevent the name already existing.\r\n                //\r\n                // Possible errors:\r\n                // `TransactionInactiveError` - if the upgrade had already aborted,\r\n                //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\r\n                //      the store but then abort the transaction.\r\n                // `SyntaxError` - if an invalid `storeParams.keyPath` is supplied.\r\n                // `InvalidAccessError` - if `storeParams.autoIncrement` is `true` and `storeParams.keyPath` is an\r\n                //      empty string or any sequence (empty or otherwise).\r\n                this.addStore(storeName, storeParams); // May throw\r\n            }\r\n        }\r\n        return [store, newStore];\r\n    }\r\n    _createIndex (store, indexes, indexName, mergePatch) {\r\n        let newIndex = indexes[indexName];\r\n        let indexParams = {};\r\n        function setCanonicalProps (indexProp) {\r\n            let canonicalPropValue;\r\n            if (hasOwn(newIndex, indexProp)) {\r\n                canonicalPropValue = newIndex[indexProp];\r\n            } else {\r\n                canonicalPropValue = indexProp === 'keyPath' ? null : false;\r\n            }\r\n            if (mergePatch && typeof canonicalPropValue === 'string') {\r\n                if (canonicalPropValue === '\\0') {\r\n                    canonicalPropValue = indexProp === 'keyPath' ? null : false;\r\n                } else {\r\n                    canonicalPropValue = canonicalPropValue.replace(/^\\0/, ''); // Remove escape if present\r\n                }\r\n            }\r\n            indexParams[indexProp] = canonicalPropValue;\r\n        }\r\n        try {\r\n            ['keyPath', 'unique', 'multiEntry', 'locale'].forEach(setCanonicalProps);\r\n            if (!store || !store.indexNames.contains(indexName)) {\r\n                throw new Error('goto catch to build index');\r\n            }\r\n            const oldIndex = store.index(indexName);\r\n            if (!['keyPath', 'unique', 'multiEntry', 'locale'].every((indexProp) => {\r\n                return compareStringified(indexParams[indexProp], oldIndex[indexProp]);\r\n            })) {\r\n                this.delIndex(indexName);\r\n                throw new Error('goto catch to build index');\r\n            }\r\n        } catch (err) {\r\n            if (err.message !== 'goto catch to build index') {\r\n                throw err;\r\n            }\r\n            // Errors for which we are not concerned and why:\r\n            // `InvalidStateError` - We are in the upgrade transaction and store found above should not have already been deleted.\r\n            // `ConstraintError` - We have already tried getting the index, so it shouldn't already exist\r\n            //\r\n            // Possible errors:\r\n            // `TransactionInactiveError` - if the upgrade had already aborted,\r\n            //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\r\n            //      the index object but then abort the transaction.\r\n            // `SyntaxError` - If the `keyPath` (second argument) is an invalid key path\r\n            // `InvalidAccessError` - If `multiEntry` on `index` is `true` and\r\n            //                          `keyPath` (second argument) is a sequence\r\n            this.addIndex(indexName, indexParams.keyPath !== null ? indexParams.keyPath : indexName, indexParams);\r\n        }\r\n    }\r\n    createIdbSchemaPatchSchema (schema) {\r\n        schema(this); // May throw\r\n    }\r\n    // Modified JSON Merge Patch type schemas: https://github.com/json-schema-org/json-schema-spec/issues/15#issuecomment-211142145\r\n    createMergePatchSchema (schema) {\r\n        this._setup(schema, (e, db, transaction) => {\r\n            Object.keys(schema).forEach((storeName) => {\r\n                const schemaObj = schema[storeName];\r\n                const isNUL = schemaObj === '\\0';\r\n                if (isNUL) {\r\n                    this.delStore(storeName);\r\n                    return;\r\n                }\r\n                if (!schemaObj || typeof schemaObj !== 'object') {\r\n                    throw new Error('Invalid merge patch schema object (type: ' + typeof schemaObj + '): ' + schemaObj);\r\n                }\r\n                const [store] = this._createStoreIfNotSame(db, transaction, schema, storeName, true);\r\n                if (hasOwn(schemaObj, 'indexes')) {\r\n                    const indexes = schemaObj.indexes;\r\n                    const isNUL = indexes === '\\0';\r\n                    if (isNUL) {\r\n                        this._deleteIndexes(transaction, storeName);\r\n                        return;\r\n                    }\r\n                    if (!indexes || typeof indexes !== 'object') {\r\n                        throw new Error('Invalid merge patch indexes object (type: ' + typeof indexes + '): ' + indexes);\r\n                    }\r\n                    Object.keys(indexes).forEach((indexName) => {\r\n                        const indexObj = indexes[indexName];\r\n                        const isNUL = indexObj === '\\0';\r\n                        if (isNUL) {\r\n                            this.delIndex(indexName);\r\n                            return;\r\n                        }\r\n                        if (!indexObj || typeof indexObj !== 'object') {\r\n                            throw new Error('Invalid merge patch index object (type: ' + typeof indexObj + '): ' + indexObj);\r\n                        }\r\n                        this._createIndex(store, indexes, indexName, true);\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n    createWholePatchSchema (schema, clearUnusedStores = true, clearUnusedIndexes = true) {\r\n        this._setup(schema, (e, db, transaction) => {\r\n            this._deleteAllUnused(db, transaction, schema, clearUnusedStores, clearUnusedIndexes);\r\n\r\n            Object.keys(schema).forEach((storeName) => {\r\n                const [store, newStore] = this._createStoreIfNotSame(db, transaction, schema, storeName);\r\n                const indexes = newStore.indexes;\r\n                Object.keys(indexes || {}).forEach((indexName) => {\r\n                    this._createIndex(store, indexes, indexName);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    createVersionedSchema (schemas, schemaType, clearUnusedStores, clearUnusedIndexes) {\r\n        const createPatches = (schemaObj, schemaType) => {\r\n            switch (schemaType) {\r\n            case 'mixed': {\r\n                schemaObj.forEach((mixedObj) => {\r\n                    const schemaType = Object.keys(mixedObj)[0];\r\n                    let schema = mixedObj[schemaType];\r\n                    if (schemaType !== 'idb-schema' && schema === 'function') {\r\n                        schema = schema(this); // May throw\r\n                    }\r\n                    // These could immediately throw with a bad version\r\n                    switch (schemaType) {\r\n                    case 'idb-schema': { // Function called above\r\n                        this.createIdbSchemaPatchSchema(schema);\r\n                        break;\r\n                    }\r\n                    case 'merge': {\r\n                        this.createMergePatchSchema(schema);\r\n                        break;\r\n                    }\r\n                    case 'whole': {\r\n                        this.createWholePatchSchema(schema, clearUnusedStores, clearUnusedIndexes);\r\n                        break;\r\n                    }\r\n                    case 'mixed': {\r\n                        createPatches(schema, schemaType);\r\n                        break;\r\n                    }\r\n                    default:\r\n                        throw new Error('Unrecognized schema type');\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case 'merge': {\r\n                this.createMergePatchSchema(schemaObj);\r\n                break;\r\n            }\r\n            case 'idb-schema': {\r\n                this.createIdbSchemaPatchSchema(schemaObj);\r\n                break;\r\n            }\r\n            case 'whole': {\r\n                this.createWholePatchSchema(schemaObj, clearUnusedStores, clearUnusedIndexes);\r\n                break;\r\n            }\r\n            }\r\n        };\r\n        Object.keys(schemas || {}).sort().forEach((schemaVersion) => {\r\n            const version = parseInt(schemaVersion, 10);\r\n            let schemaObj = schemas[version];\r\n            if (schemaType !== 'idb-schema' && typeof schemaObj === 'function') {\r\n                schemaObj = schemaObj(this); // May throw\r\n            }\r\n            this.version(version);\r\n            createPatches(schemaObj, schemaType, version);\r\n        });\r\n    }\r\n}\r\n"]}