{"version":3,"sources":["../src/idb-import.js"],"names":["hasOwn","Object","prototype","hasOwnProperty","stringify","JSON","compareStringified","a","b","_possibleConstructorReturn","this","getPrototypeOf","IdbImport","call","schema","_typeof","Error","addEarlyCallback","e","db","target","result","clearUnusedStores","Array","from","objectStoreNames","forEach","name","keys","some","tableName","table","store","contains","transaction","objectStore","_this2","getStore","every","storeProp","canonicalPropValue","key","delStore","addStore","indexes","indexKey","index","indexProp","oldIndex","delIndex","err","addIndex","keyPath"],"mappings":"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","file":"idb-import.min.js","sourcesContent":["self._babelPolyfill = false; // Need by Phantom in avoiding duplicate babel polyfill error\r\nimport IdbSchema from 'idb-schema';\r\n\r\nconst hasOwn = Object.prototype.hasOwnProperty;\r\nconst stringify = JSON.stringify;\r\nconst compareStringified = (a, b) => {\r\n    return stringify(a) === stringify(b);\r\n};\r\n\r\nexport default class IdbImport extends IdbSchema {\r\n    constructor () {\r\n        super();\r\n    }\r\n    createSchema (schema, version, clearUnusedStores) {\r\n        if (!schema || typeof schema !== 'object') {\r\n            throw new Error('Bad schema object');\r\n        }\r\n        this.version(version);\r\n\r\n        this.addEarlyCallback((e) => {\r\n            const db = e.target.result;\r\n            const transaction = e.target.transaction;\r\n\r\n            if (clearUnusedStores) {\r\n                Array.from(db.objectStoreNames).forEach((name) => {\r\n                    if (!hasOwn.call(schema, name)) {\r\n                        // Errors for which we are not concerned and why:\r\n                        // `InvalidStateError` - We are in the upgrade transaction.\r\n                        // `TransactionInactiveError` (as by the upgrade having already\r\n                        //      completed or somehow aborting) - since we've just started and\r\n                        //      should be without risk in this loop\r\n                        // `NotFoundError` - since we are iterating the dynamically updated\r\n                        //      `objectStoreNames`\r\n                        this._versions[version].dropStores.push({name: name});\r\n                        // this.delStore(name); // Shouldn't throw // Uncomment this and delete previous line if this PR is accepted: https://github.com/treojs/idb-schema/pull/14\r\n                    }\r\n                });\r\n            }\r\n\r\n            Object.keys(schema).some((tableName) => {\r\n                const table = schema[tableName];\r\n                let store;\r\n                if (db.objectStoreNames.contains(tableName)) {\r\n                    store = transaction.objectStore(tableName); // Shouldn't throw\r\n                    this.getStore(store);\r\n                    if (!['keyPath', 'autoIncrement'].every((storeProp) => {\r\n                        let canonicalPropValue;\r\n                        if (hasOwn.call(table, 'key')) { // Support old approach of db.js\r\n                            canonicalPropValue = table.key[storeProp];\r\n                        } else if (hasOwn.call(table, storeProp)) {\r\n                            canonicalPropValue = table[storeProp];\r\n                        } else {\r\n                            canonicalPropValue = storeProp === 'keyPath' ? null : false;\r\n                        }\r\n                        return compareStringified(canonicalPropValue, store[storeProp]);\r\n                    })) {\r\n                        this.delStore(tableName);\r\n                        throw new Error('goto catch to rebuild store');\r\n                    }\r\n                } else {\r\n                    // Errors for which we are not concerned and why:\r\n                    // `InvalidStateError` - We are in the upgrade transaction.\r\n                    // `ConstraintError` - We are just starting (and probably never too large anyways) for a key generator.\r\n                    // `ConstraintError` - The above condition should prevent the name already existing.\r\n                    //\r\n                    // Possible errors:\r\n                    // `TransactionInactiveError` - if the upgrade had already aborted,\r\n                    //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\r\n                    //      the store but then abort the transaction.\r\n                    // `SyntaxError` - if an invalid `table.key.keyPath` is supplied.\r\n                    // `InvalidAccessError` - if `table.key.autoIncrement` is `true` and `table.key.keyPath` is an\r\n                    //      empty string or any sequence (empty or otherwise).\r\n                    this.addStore(tableName, table.key); // May throw\r\n                }\r\n\r\n                Object.keys(table.indexes || {}).some((indexKey) => {\r\n                    let index = table.indexes[indexKey];\r\n                    try {\r\n                        const oldIndex = store.index(indexKey);\r\n\r\n                        if (!['keyPath', 'unique', 'multiEntry'].every((indexProp) => {\n                            let canonicalPropValue;\r\n                            if (hasOwn.call(table, indexProp)) {\r\n                                canonicalPropValue = index[indexProp];\r\n                            } else {\r\n                                canonicalPropValue = indexProp === 'keyPath' ? null : false;\r\n                            }\r\n                            return compareStringified(canonicalPropValue, oldIndex[indexProp]);\r\n                        })) {\r\n                            this.delIndex(indexKey);\r\n                            throw new Error('goto catch to rebuild index');\r\n                        }\r\n                    } catch (err) {\r\n                        index = index && typeof index === 'object' ? index : {};\r\n                        // Errors for which we are not concerned and why:\r\n                        // `InvalidStateError` - We are in the upgrade transaction and store found above should not have already been deleted.\r\n                        // `ConstraintError` - We have already tried getting the index, so it shouldn't already exist\r\n                        //\r\n                        // Possible errors:\r\n                        // `TransactionInactiveError` - if the upgrade had already aborted,\r\n                        //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\r\n                        //      the index object but then abort the transaction.\r\n                        // `SyntaxError` - If the `keyPath` (second argument) is an invalid key path\r\n                        // `InvalidAccessError` - If `multiEntry` on `index` is `true` and\r\n                        //                          `keyPath` (second argument) is a sequence\r\n                        this.addIndex(indexKey, index.keyPath || index.key || indexKey, index);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\r\n"]}