{"version":3,"sources":["../src/idb-import.js"],"names":["_possibleConstructorReturn","this","Object","getPrototypeOf","IdbImport","call","schema","_typeof","Error","addEarlyCallback","e","db","target","result","clearUnusedStores","Array","from","objectStoreNames","forEach","name","keys","some","tableName","table","store","contains","transaction","objectStore","_this2","getStore","addStore","key","indexes","indexKey","index","err","addIndex","keyPath"],"mappings":"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","file":"idb-import.min.js","sourcesContent":["self._babelPolyfill = false; // Need by Phantom in avoiding duplicate babel polyfill error\r\nimport IdbSchema from 'idb-schema';\r\n\r\nconst hasOwn = Object.prototype.hasOwnProperty;\r\n\r\nexport default class IdbImport extends IdbSchema {\r\n    constructor () {\r\n        super();\r\n    }\r\n    createSchema (schema, version, clearUnusedStores) {\r\n        if (!schema || typeof schema !== 'object') {\r\n            throw new Error('Bad schema object');\r\n        }\r\n        this.version(version);\r\n\r\n        this.addEarlyCallback((e) => {\r\n            const db = e.target.result;\r\n            const transaction = e.target.transaction;\r\n\r\n            if (clearUnusedStores) {\r\n                Array.from(db.objectStoreNames).forEach((name) => {\r\n                    if (!hasOwn.call(schema, name)) {\r\n                        // Errors for which we are not concerned and why:\r\n                        // `InvalidStateError` - We are in the upgrade transaction.\r\n                        // `TransactionInactiveError` (as by the upgrade having already\r\n                        //      completed or somehow aborting) - since we've just started and\r\n                        //      should be without risk in this loop\r\n                        // `NotFoundError` - since we are iterating the dynamically updated\r\n                        //      `objectStoreNames`\r\n                        this._versions[version].dropStores.push({name: name});\r\n                        // this.delStore(name); // Shouldn't throw // Uncomment this and delete previous line if this PR is accepted: https://github.com/treojs/idb-schema/pull/14\r\n                    }\r\n                });\r\n            }\r\n\r\n            Object.keys(schema).some((tableName) => {\r\n                const table = schema[tableName];\r\n                let store;\r\n                if (db.objectStoreNames.contains(tableName)) {\r\n                    store = transaction.objectStore(tableName); // Shouldn't throw\r\n                    this.getStore(store);\r\n                } else {\r\n                    // Errors for which we are not concerned and why:\r\n                    // `InvalidStateError` - We are in the upgrade transaction.\r\n                    // `ConstraintError` - We are just starting (and probably never too large anyways) for a key generator.\r\n                    // `ConstraintError` - The above condition should prevent the name already existing.\r\n                    //\r\n                    // Possible errors:\r\n                    // `TransactionInactiveError` - if the upgrade had already aborted,\r\n                    //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\r\n                    //      the store but then abort the transaction.\r\n                    // `SyntaxError` - if an invalid `table.key.keyPath` is supplied.\r\n                    // `InvalidAccessError` - if `table.key.autoIncrement` is `true` and `table.key.keyPath` is an\r\n                    //      empty string or any sequence (empty or otherwise).\r\n                    this.addStore(tableName, table.key); // May throw\r\n                }\r\n\r\n                Object.keys(table.indexes || {}).some((indexKey) => {\r\n                    try {\r\n                        store.index(indexKey);\r\n                    } catch (err) {\r\n                        let index = table.indexes[indexKey];\r\n                        index = index && typeof index === 'object' ? index : {};\r\n                        // Errors for which we are not concerned and why:\r\n                        // `InvalidStateError` - We are in the upgrade transaction and store found above should not have already been deleted.\r\n                        // `ConstraintError` - We have already tried getting the index, so it shouldn't already exist\r\n                        //\r\n                        // Possible errors:\r\n                        // `TransactionInactiveError` - if the upgrade had already aborted,\r\n                        //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\r\n                        //      the index object but then abort the transaction.\r\n                        // `SyntaxError` - If the `keyPath` (second argument) is an invalid key path\r\n                        // `InvalidAccessError` - If `multiEntry` on `index` is `true` and\r\n                        //                          `keyPath` (second argument) is a sequence\r\n                        this.addIndex(indexKey, index.keyPath || index.key || indexKey, index);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\r\n"]}