{"version":3,"sources":["../src/idb-import.js"],"names":["hasOwn","JSON","stringify","Object","hasOwnProperty","prototype","call","obj","prop","compareStringified","a","b","IdbImport","_possibleConstructorReturn","this","__proto__","getPrototypeOf","IdbSchema","value","schema","cb","mergePatch","isNUL","_typeof","Error","addEarlyCallback","result","e","transaction","_deleteAllUnused","_this2","db","storeName","exceptionIndexes","Array","store","indexNames","from","forEach","indexName","_this3","delIndex","clearUnusedStores","clearUnusedIndexes","objectStoreNames","moveFrom","key","copyFrom","includes","_this4","delStore","_deleteIndexes","indexes","canonicalPropValue","newStore","storeProp","replace","storeParams","contains","getStore","objectStore","err","message","copyStore","renameStore","addStore","indexProp","newIndex","indexParams","setCanonicalProps","oldIndex","index","every","addIndex","keyPath","keys","schemaObj","_this5","_createStoreIfNotSame2","_createStoreIfNotSame","_slicedToArray","_isNUL","indexObj","_createIndex","arguments","length","undefined","_setup","_createStoreIfNotSame4","_this6","_createStoreIfNotSame5","schemas","schemaType","createPatches","mixedObj","_this7","createIdbSchemaPatchSchema","createMergePatchSchema","createWholePatchSchema","version","schemaVersion"],"mappings":"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","file":"idb-import.min.js","sourcesContent":["/*\n# Notes\n\n1. Could use/adapt [jtlt](https://github.com/brettz9/jtlt/) for changing JSON data\n\n# Possible to-dos\n\n1. Support data within adapted JSON Merge Patch\n1. Allow JSON Schema to be specified during import (and export): https://github.com/aaronpowell/db.js/issues/181\n1. JSON format above database level to allow for deleting or moving/copying of whole databases\n1. `copyFrom`/`moveFrom` for indexes\n*/\n\nself._babelPolyfill = false; // Need by Phantom in avoiding duplicate babel polyfill error\nimport IdbSchema from 'idb-schema';\n\nconst stringify = JSON.stringify;\nconst hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nconst compareStringified = (a, b) => stringify(a) === stringify(b);\n\nexport default class IdbImport extends IdbSchema {\n    constructor () {\n        super();\n    }\n    _setup (schema, cb, mergePatch) {\n        const isNUL = schema === '\\0';\n        if (!schema || typeof schema !== 'object' && !(mergePatch && isNUL)) {\n            throw new Error('Bad schema object');\n        }\n        this.addEarlyCallback((e) => {\n            const db = e.target.result;\n            const transaction = e.target.transaction;\n            if (mergePatch && isNUL) {\n                this._deleteAllUnused(db, transaction, {}, true);\n                return;\n            }\n            return cb(e, db, transaction);\n        });\n    }\n    _deleteIndexes (transaction, storeName, exceptionIndexes) {\n        const store = transaction.objectStore(storeName); // Shouldn't throw\n        Array.from(store.indexNames).forEach((indexName) => {\n            if (!exceptionIndexes || !hasOwn(exceptionIndexes, indexName)) {\n                this.delIndex(indexName);\n            }\n        });\n    }\n    _deleteAllUnused (db, transaction, schema, clearUnusedStores, clearUnusedIndexes) {\n        if (clearUnusedStores || clearUnusedIndexes) {\n            Array.from(db.objectStoreNames).forEach((storeName) => {\n                if (clearUnusedStores && !hasOwn(schema, storeName)) {\n                    // Errors for which we are not concerned and why:\n                    // `InvalidStateError` - We are in the upgrade transaction.\n                    // `TransactionInactiveError` (as by the upgrade having already\n                    //      completed or somehow aborting) - since we've just started and\n                    //      should be without risk in this loop\n                    // `NotFoundError` - since we are iterating the dynamically updated\n                    //      `objectStoreNames`\n                    // this._versions[version].dropStores.push({name: storeName});\n                    // Avoid deleting if going to delete in a move/copy\n                    if (!Object.keys(schema).some((key) => [schema[key].moveFrom, schema[key].copyFrom].includes(storeName))) {\n                        this.delStore(storeName); // Shouldn't throw // Keep this and delete previous line if this PR is accepted: https://github.com/treojs/idb-schema/pull/14\n                    }\n                } else if (clearUnusedIndexes) {\n                    this._deleteIndexes(transaction, storeName, schema[storeName].indexes);\n                }\n            });\n        }\n    }\n    _createStoreIfNotSame (db, transaction, schema, storeName, mergePatch) {\n        const newStore = schema[storeName];\n        let store;\n        let storeParams = {};\n        function setCanonicalProps (storeProp) {\n            let canonicalPropValue;\n            if (hasOwn(newStore, 'key')) { // Support old approach of db.js\n                canonicalPropValue = newStore.key[storeProp];\n            } else if (hasOwn(newStore, storeProp)) {\n                canonicalPropValue = newStore[storeProp];\n            } else {\n                canonicalPropValue = storeProp === 'keyPath' ? null : false;\n            }\n            if (mergePatch && typeof canonicalPropValue === 'string') {\n                if (canonicalPropValue === '\\0') {\n                    canonicalPropValue = storeProp === 'keyPath' ? null : false;\n                } else {\n                    canonicalPropValue = canonicalPropValue.replace(/^\\0/, ''); // Remove escape if present\n                }\n            }\n            storeParams[storeProp] = canonicalPropValue;\n        }\n        const copyFrom = newStore.copyFrom;\n        const moveFrom = newStore.moveFrom;\n        try {\n            ['keyPath', 'autoIncrement'].forEach(setCanonicalProps);\n            if (!db.objectStoreNames.contains(storeName)) {\n                throw new Error('goto catch to build store');\n            }\n            store = transaction.objectStore(storeName); // Shouldn't throw\n            this.getStore(store);\n            if (!['keyPath', 'autoIncrement'].every((storeProp) => {\n                return compareStringified(storeParams[storeProp], store[storeProp]);\n            })) {\n                // Avoid deleting if going to delete in a move/copy\n                if (!copyFrom && !moveFrom) this.delStore(storeName);\n                throw new Error('goto catch to build store');\n            }\n        } catch (err) {\n            if (err.message !== 'goto catch to build store') {\n                throw err;\n            }\n            if (copyFrom) {\n                this.copyStore(copyFrom, storeName, storeParams); // May throw\n            } else if (moveFrom) {\n                this.renameStore(moveFrom, storeName, storeParams); // May throw\n            } else {\n                // Errors for which we are not concerned and why:\n                // `InvalidStateError` - We are in the upgrade transaction.\n                // `ConstraintError` - We are just starting (and probably never too large anyways) for a key generator.\n                // `ConstraintError` - The above condition should prevent the name already existing.\n                //\n                // Possible errors:\n                // `TransactionInactiveError` - if the upgrade had already aborted,\n                //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\n                //      the store but then abort the transaction.\n                // `SyntaxError` - if an invalid `storeParams.keyPath` is supplied.\n                // `InvalidAccessError` - if `storeParams.autoIncrement` is `true` and `storeParams.keyPath` is an\n                //      empty string or any sequence (empty or otherwise).\n                this.addStore(storeName, storeParams); // May throw\n            }\n        }\n        return [store, newStore];\n    }\n    _createIndex (store, indexes, indexName, mergePatch) {\n        let newIndex = indexes[indexName];\n        let indexParams = {};\n        function setCanonicalProps (indexProp) {\n            let canonicalPropValue;\n            if (hasOwn(newIndex, indexProp)) {\n                canonicalPropValue = newIndex[indexProp];\n            } else {\n                canonicalPropValue = indexProp === 'keyPath' ? null : false;\n            }\n            if (mergePatch && typeof canonicalPropValue === 'string') {\n                if (canonicalPropValue === '\\0') {\n                    canonicalPropValue = indexProp === 'keyPath' ? null : false;\n                } else {\n                    canonicalPropValue = canonicalPropValue.replace(/^\\0/, ''); // Remove escape if present\n                }\n            }\n            indexParams[indexProp] = canonicalPropValue;\n        }\n        try {\n            ['keyPath', 'unique', 'multiEntry', 'locale'].forEach(setCanonicalProps);\n            if (!store || !store.indexNames.contains(indexName)) {\n                throw new Error('goto catch to build index');\n            }\n            const oldIndex = store.index(indexName);\n            if (!['keyPath', 'unique', 'multiEntry', 'locale'].every((indexProp) => {\n                return compareStringified(indexParams[indexProp], oldIndex[indexProp]);\n            })) {\n                this.delIndex(indexName);\n                throw new Error('goto catch to build index');\n            }\n        } catch (err) {\n            if (err.message !== 'goto catch to build index') {\n                throw err;\n            }\n            // Errors for which we are not concerned and why:\n            // `InvalidStateError` - We are in the upgrade transaction and store found above should not have already been deleted.\n            // `ConstraintError` - We have already tried getting the index, so it shouldn't already exist\n            //\n            // Possible errors:\n            // `TransactionInactiveError` - if the upgrade had already aborted,\n            //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\n            //      the index object but then abort the transaction.\n            // `SyntaxError` - If the `keyPath` (second argument) is an invalid key path\n            // `InvalidAccessError` - If `multiEntry` on `index` is `true` and\n            //                          `keyPath` (second argument) is a sequence\n            this.addIndex(indexName, indexParams.keyPath !== null ? indexParams.keyPath : indexName, indexParams);\n        }\n    }\n    createIdbSchemaPatchSchema (schema) {\n        schema(this); // May throw\n    }\n    // Modified JSON Merge Patch type schemas: https://github.com/json-schema-org/json-schema-spec/issues/15#issuecomment-211142145\n    createMergePatchSchema (schema) {\n        this._setup(schema, (e, db, transaction) => {\n            Object.keys(schema).forEach((storeName) => {\n                const schemaObj = schema[storeName];\n                const isNUL = schemaObj === '\\0';\n                if (isNUL) {\n                    this.delStore(storeName);\n                    return;\n                }\n                if (!schemaObj || typeof schemaObj !== 'object') {\n                    throw new Error('Invalid merge patch schema object (type: ' + typeof schemaObj + '): ' + schemaObj);\n                }\n                const [store] = this._createStoreIfNotSame(db, transaction, schema, storeName, true);\n                if (hasOwn(schemaObj, 'indexes')) {\n                    const indexes = schemaObj.indexes;\n                    const isNUL = indexes === '\\0';\n                    if (isNUL) {\n                        this._deleteIndexes(transaction, storeName);\n                        return;\n                    }\n                    if (!indexes || typeof indexes !== 'object') {\n                        throw new Error('Invalid merge patch indexes object (type: ' + typeof indexes + '): ' + indexes);\n                    }\n                    Object.keys(indexes).forEach((indexName) => {\n                        const indexObj = indexes[indexName];\n                        const isNUL = indexObj === '\\0';\n                        if (isNUL) {\n                            this.delIndex(indexName);\n                            return;\n                        }\n                        if (!indexObj || typeof indexObj !== 'object') {\n                            throw new Error('Invalid merge patch index object (type: ' + typeof indexObj + '): ' + indexObj);\n                        }\n                        this._createIndex(store, indexes, indexName, true);\n                    });\n                }\n            });\n        });\n    }\n    createWholePatchSchema (schema, clearUnusedStores = true, clearUnusedIndexes = true) {\n        this._setup(schema, (e, db, transaction) => {\n            this._deleteAllUnused(db, transaction, schema, clearUnusedStores, clearUnusedIndexes);\n\n            Object.keys(schema).forEach((storeName) => {\n                const [store, newStore] = this._createStoreIfNotSame(db, transaction, schema, storeName);\n                const indexes = newStore.indexes;\n                Object.keys(indexes || {}).forEach((indexName) => {\n                    this._createIndex(store, indexes, indexName);\n                });\n            });\n        });\n    }\n    createVersionedSchema (schemas, schemaType, clearUnusedStores, clearUnusedIndexes) {\n        const createPatches = (schemaObj, schemaType) => {\n            switch (schemaType) {\n            case 'mixed': {\n                schemaObj.forEach((mixedObj) => {\n                    const schemaType = Object.keys(mixedObj)[0];\n                    let schema = mixedObj[schemaType];\n                    if (schemaType !== 'idb-schema' && schema === 'function') {\n                        schema = schema(this); // May throw\n                    }\n                    // These could immediately throw with a bad version\n                    switch (schemaType) {\n                    case 'idb-schema': { // Function called above\n                        this.createIdbSchemaPatchSchema(schema);\n                        break;\n                    }\n                    case 'merge': {\n                        this.createMergePatchSchema(schema);\n                        break;\n                    }\n                    case 'whole': {\n                        this.createWholePatchSchema(schema, clearUnusedStores, clearUnusedIndexes);\n                        break;\n                    }\n                    case 'mixed': {\n                        createPatches(schema, schemaType);\n                        break;\n                    }\n                    default:\n                        throw new Error('Unrecognized schema type');\n                    }\n                });\n                break;\n            }\n            case 'merge': {\n                this.createMergePatchSchema(schemaObj);\n                break;\n            }\n            case 'idb-schema': {\n                this.createIdbSchemaPatchSchema(schemaObj);\n                break;\n            }\n            case 'whole': {\n                this.createWholePatchSchema(schemaObj, clearUnusedStores, clearUnusedIndexes);\n                break;\n            }\n            }\n        };\n        Object.keys(schemas || {}).sort().forEach((schemaVersion) => {\n            const version = parseInt(schemaVersion, 10);\n            let schemaObj = schemas[version];\n            if (schemaType !== 'idb-schema' && typeof schemaObj === 'function') {\n                schemaObj = schemaObj(this); // May throw\n            }\n            this.version(version);\n            createPatches(schemaObj, schemaType, version);\n        });\n    }\n}\n"]}