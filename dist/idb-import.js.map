{"version":3,"sources":["../src/idb-import.js"],"names":[],"mappings":"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","file":"idb-import.js","sourcesContent":["/*\r\n# Notes\r\n\r\n1. Could use/adapt [jtlt](https://github.com/brettz9/jtlt/) for changing JSON data\r\n\r\n# Possible to-dos\r\n\r\n1. Support data within adapted JSON Merge Patch\r\n1. Allow JSON Schema to be specified during import (and export): https://github.com/aaronpowell/db.js/issues/181\r\n1. JSON format above database level to allow for deleting or moving/copying of whole databases\r\n1. `copyFrom`/`moveFrom` for indexes\r\n*/\r\n\r\nself._babelPolyfill = false; // Need by Phantom in avoiding duplicate babel polyfill error\r\nimport IdbSchema from 'idb-schema';\r\n\r\nconst stringify = JSON.stringify;\r\nconst hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\r\nconst compareStringified = (a, b) => stringify(a) === stringify(b);\r\n\r\nexport default class IdbImport extends IdbSchema {\r\n    constructor () {\r\n        super();\r\n    }\r\n    _setup (schema, version, cb, mergePatch) {\r\n        const isNUL = schema === '\\0';\r\n        if (!schema || typeof schema !== 'object' && !(mergePatch && isNUL)) {\r\n            throw new Error('Bad schema object');\r\n        }\r\n        this.version(version);\r\n        this.addEarlyCallback((e) => {\r\n            const db = e.target.result;\r\n            const transaction = e.target.transaction;\r\n            if (mergePatch && isNUL) {\r\n                this._deleteAllUnused(db, transaction, {}, true);\r\n                return;\r\n            }\r\n            return cb(e, db, transaction);\r\n        });\r\n    }\r\n    _deleteIndexes (transaction, storeName, exceptionIndexes) {\r\n        const store = transaction.objectStore(storeName); // Shouldn't throw\r\n        Array.from(store.indexNames).forEach((indexName) => {\r\n            if (!exceptionIndexes || !hasOwn(exceptionIndexes, indexName)) {\r\n                this.delIndex(indexName);\r\n            }\r\n        });\r\n    }\r\n    _deleteAllUnused (db, transaction, schema, clearUnusedStores, clearUnusedIndexes) {\r\n        if (clearUnusedStores || clearUnusedIndexes) {\r\n            Array.from(db.objectStoreNames).forEach((storeName) => {\r\n                if (clearUnusedStores && !hasOwn(schema, storeName)) {\r\n                    // Errors for which we are not concerned and why:\r\n                    // `InvalidStateError` - We are in the upgrade transaction.\r\n                    // `TransactionInactiveError` (as by the upgrade having already\r\n                    //      completed or somehow aborting) - since we've just started and\r\n                    //      should be without risk in this loop\r\n                    // `NotFoundError` - since we are iterating the dynamically updated\r\n                    //      `objectStoreNames`\r\n                    // this._versions[version].dropStores.push({name: storeName});\r\n                    this.delStore(storeName); // Shouldn't throw // Keep this and delete previous line if this PR is accepted: https://github.com/treojs/idb-schema/pull/14\r\n                } else if (clearUnusedIndexes) {\r\n                    this._deleteIndexes(transaction, storeName, schema[storeName].indexes);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    _createStoreIfNotSame (db, transaction, schema, storeName, mergePatch) {\r\n        const newStore = schema[storeName];\r\n        let store;\r\n        let storeParams = {};\r\n        function setCanonicalProps (storeProp) {\r\n            let canonicalPropValue;\r\n            if (hasOwn(newStore, 'key')) { // Support old approach of db.js\r\n                canonicalPropValue = newStore.key[storeProp];\r\n            } else if (hasOwn(newStore, storeProp)) {\r\n                canonicalPropValue = newStore[storeProp];\r\n            } else {\r\n                canonicalPropValue = storeProp === 'keyPath' ? null : false;\r\n            }\r\n            if (mergePatch && typeof canonicalPropValue === 'string') {\r\n                if (canonicalPropValue === '\\0') {\r\n                    canonicalPropValue = storeProp === 'keyPath' ? null : false;\r\n                } else {\r\n                    canonicalPropValue = canonicalPropValue.replace(/^\\0/, ''); // Remove escape if present\r\n                }\r\n            }\r\n            storeParams[storeProp] = canonicalPropValue;\r\n        }\r\n        const copyFrom = newStore.copyFrom;\r\n        const moveFrom = newStore.moveFrom;\r\n        try {\r\n            ['keyPath', 'autoIncrement'].forEach(setCanonicalProps);\r\n            if (!db.objectStoreNames.contains(storeName)) {\r\n                throw new Error('goto catch to build store');\r\n            }\r\n            store = transaction.objectStore(storeName); // Shouldn't throw\r\n            this.getStore(store);\r\n            if (!['keyPath', 'autoIncrement'].every((storeProp) => {\r\n                return compareStringified(storeParams[storeProp], store[storeProp]);\r\n            })) {\r\n                this.delStore(storeName);\r\n                throw new Error('goto catch to build store');\r\n            }\r\n        } catch (err) {\r\n            if (err.message !== 'goto catch to build store') {\r\n                throw err;\r\n            }\r\n            if (copyFrom) {\r\n                this.copyStore(copyFrom, storeName, storeParams); // May throw\r\n            } else if (moveFrom) {\r\n                this.renameStore(moveFrom, storeName, storeParams); // May throw\r\n            } else {\r\n                // Errors for which we are not concerned and why:\r\n                // `InvalidStateError` - We are in the upgrade transaction.\r\n                // `ConstraintError` - We are just starting (and probably never too large anyways) for a key generator.\r\n                // `ConstraintError` - The above condition should prevent the name already existing.\r\n                //\r\n                // Possible errors:\r\n                // `TransactionInactiveError` - if the upgrade had already aborted,\r\n                //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\r\n                //      the store but then abort the transaction.\r\n                // `SyntaxError` - if an invalid `storeParams.keyPath` is supplied.\r\n                // `InvalidAccessError` - if `storeParams.autoIncrement` is `true` and `storeParams.keyPath` is an\r\n                //      empty string or any sequence (empty or otherwise).\r\n                this.addStore(storeName, storeParams); // May throw\r\n            }\r\n        }\r\n        return [store, newStore];\r\n    }\r\n    _createIndex (store, indexes, indexName, mergePatch) {\r\n        let newIndex = indexes[indexName];\r\n        let indexParams = {};\r\n        function setCanonicalProps (indexProp) {\r\n            let canonicalPropValue;\r\n            if (hasOwn(newIndex, indexProp)) {\r\n                canonicalPropValue = newIndex[indexProp];\r\n            } else {\r\n                canonicalPropValue = indexProp === 'keyPath' ? null : false;\r\n            }\r\n            if (mergePatch && typeof canonicalPropValue === 'string') {\r\n                if (canonicalPropValue === '\\0') {\r\n                    canonicalPropValue = indexProp === 'keyPath' ? null : false;\r\n                } else {\r\n                    canonicalPropValue = canonicalPropValue.replace(/^\\0/, ''); // Remove escape if present\r\n                }\r\n            }\r\n            indexParams[indexProp] = canonicalPropValue;\r\n        }\r\n        try {\r\n            ['keyPath', 'unique', 'multiEntry', 'locale'].forEach(setCanonicalProps);\r\n            if (!store || !store.indexNames.contains(indexName)) {\r\n                throw new Error('goto catch to build index');\r\n            }\r\n            const oldIndex = store.index(indexName);\r\n            if (!['keyPath', 'unique', 'multiEntry', 'locale'].every((indexProp) => {\r\n                return compareStringified(indexParams[indexProp], oldIndex[indexProp]);\r\n            })) {\r\n                this.delIndex(indexName);\r\n                throw new Error('goto catch to build index');\r\n            }\r\n        } catch (err) {\r\n            if (err.message !== 'goto catch to build index') {\r\n                throw err;\r\n            }\r\n            // Errors for which we are not concerned and why:\r\n            // `InvalidStateError` - We are in the upgrade transaction and store found above should not have already been deleted.\r\n            // `ConstraintError` - We have already tried getting the index, so it shouldn't already exist\r\n            //\r\n            // Possible errors:\r\n            // `TransactionInactiveError` - if the upgrade had already aborted,\r\n            //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\r\n            //      the index object but then abort the transaction.\r\n            // `SyntaxError` - If the `keyPath` (second argument) is an invalid key path\r\n            // `InvalidAccessError` - If `multiEntry` on `index` is `true` and\r\n            //                          `keyPath` (second argument) is a sequence\r\n            this.addIndex(indexName, indexParams.keyPath !== null ? indexParams.keyPath : indexName, indexParams);\r\n        }\r\n    }\r\n    // Modified JSON Merge Patch type schemas: https://github.com/json-schema-org/json-schema-spec/issues/15#issuecomment-211142145\r\n    createMergePatchSchema (schema, version) {\r\n        this._setup(schema, version, (e, db, transaction) => {\r\n            Object.keys(schema).forEach((storeName) => {\r\n                const schemaObj = schema[storeName];\r\n                const isNUL = schemaObj === '\\0';\r\n                if (isNUL) {\r\n                    this.delStore(storeName);\r\n                    return;\r\n                }\r\n                if (!schemaObj || typeof schemaObj !== 'object') {\r\n                    throw new Error('Invalid merge patch schema object (type: ' + typeof schemaObj + '): ' + schemaObj);\r\n                }\r\n                let store;\r\n                if (['key', 'keyPath', 'autoIncrement', 'copyFrom', 'moveFrom'].some((prop) => hasOwn(schemaObj, prop))) {\r\n                    [store] = this._createStoreIfNotSame(db, transaction, schema, storeName, true);\r\n                }\r\n                if (hasOwn(schemaObj, 'indexes')) {\r\n                    const indexes = schemaObj.indexes;\r\n                    const isNUL = indexes === '\\0';\r\n                    if (isNUL) {\r\n                        this._deleteIndexes(transaction, storeName);\r\n                        return;\r\n                    }\r\n                    if (!indexes || typeof indexes !== 'object') {\r\n                        throw new Error('Invalid merge patch indexes object (type: ' + typeof indexes + '): ' + indexes);\r\n                    }\r\n                    Object.keys(indexes).forEach((indexName) => {\r\n                        const indexObj = indexes[indexName];\r\n                        const isNUL = indexObj === '\\0';\r\n                        if (isNUL) {\r\n                            this.delIndex(indexName);\r\n                            return;\r\n                        }\r\n                        if (!indexObj || typeof indexObj !== 'object') {\r\n                            throw new Error('Invalid merge patch index object (type: ' + typeof indexObj + '): ' + indexObj);\r\n                        }\r\n                        this._createIndex(store, indexes, indexName, true);\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n    createWholePatchSchema (schema, version, clearUnusedStores = true, clearUnusedIndexes = true) {\r\n        this._setup(schema, version, (e, db, transaction) => {\r\n            this._deleteAllUnused(db, transaction, schema, clearUnusedStores, clearUnusedIndexes);\r\n\r\n            Object.keys(schema).forEach((storeName) => {\r\n                const [store, newStore] = this._createStoreIfNotSame(db, transaction, schema, storeName);\r\n                const indexes = newStore.indexes;\r\n                Object.keys(indexes || {}).forEach((indexName) => {\r\n                    this._createIndex(store, indexes, indexName);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    createVersionedSchema (schemas, schemaType, clearUnusedStores, clearUnusedIndexes) {\r\n        Object.keys(schemas || {}).sort().forEach((schemaVersion) => {\r\n            const version = parseInt(schemaVersion, 10);\r\n            let schemaObj = schemas[version];\r\n            if (typeof schemaObj === 'function') {\r\n                schemaObj = schemaObj(this); // May throw\r\n            }\r\n\r\n            switch (schemaType) {\r\n            case 'idb-schema': { // Function called above\r\n                break;\r\n            }\r\n            case 'mixed': {\r\n                schemaObj.forEach((mixedObj) => {\r\n                    const schemaType = Object.keys(mixedObj)[0];\r\n                    let schema = mixedObj[schemaType];\r\n                    if (typeof schema === 'function') {\r\n                        schema = schema(this); // May throw\r\n                    }\r\n                    // These could immediately throw with a bad version\r\n                    switch (schemaType) {\r\n                    case 'idb-schema': { // Function called above\r\n                        break;\r\n                    }\r\n                    case 'merge': {\r\n                        this.createMergePatchSchema(schema, version);\r\n                        break;\r\n                    }\r\n                    case 'whole': {\r\n                        this.createWholePatchSchema(schema, version, clearUnusedStores, clearUnusedIndexes);\r\n                        break;\r\n                    }\r\n                    default:\r\n                        throw new Error('Unrecognized schema type');\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case 'merge': {\r\n                this.createMergePatchSchema(schemaObj, version);\r\n                break;\r\n            }\r\n            case 'whole': {\r\n                this.createWholePatchSchema(schemaObj, version, clearUnusedStores, clearUnusedIndexes);\r\n                break;\r\n            }\r\n            }\r\n        });\r\n    }\r\n}\r\n"]}