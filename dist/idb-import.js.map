{"version":3,"sources":["../src/idb-import.js"],"names":["self","_babelPolyfill","stringify","JSON","hasOwn","obj","prop","Object","prototype","hasOwnProperty","call","compareStringified","a","b","IdbImport","schema","cb","mergePatch","isNUL","Error","addEarlyCallback","e","db","target","result","transaction","_deleteAllUnused","storeName","exceptionIndexes","store","objectStore","Array","from","indexNames","forEach","indexName","delIndex","clearUnusedStores","clearUnusedIndexes","objectStoreNames","keys","some","key","moveFrom","copyFrom","includes","delStore","_deleteIndexes","indexes","newStore","storeParams","setCanonicalProps","storeProp","canonicalPropValue","replace","contains","getStore","every","err","message","copyStore","renameStore","addStore","newIndex","indexParams","indexProp","oldIndex","index","addIndex","keyPath","_setup","schemaObj","_createStoreIfNotSame","indexObj","_createIndex","schemas","schemaType","createPatches","mixedObj","createIdbSchemaPatchSchema","createMergePatchSchema","createWholePatchSchema","sort","schemaVersion","version","parseInt","IdbSchema"],"mappings":"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","file":"idb-import.js","sourcesContent":["/*\n# Notes\n\n1. Could use/adapt [jtlt](https://github.com/brettz9/jtlt/) for changing JSON data\n\n# Possible to-dos\n\n1. Support data within adapted JSON Merge Patch\n1. Allow JSON Schema to be specified during import (and export): https://github.com/aaronpowell/db.js/issues/181\n1. JSON format above database level to allow for deleting or moving/copying of whole databases\n1. `copyFrom`/`moveFrom` for indexes\n*/\n\nself._babelPolyfill = false; // Need by Phantom in avoiding duplicate babel polyfill error\nimport IdbSchema from 'idb-schema';\n\nconst stringify = JSON.stringify;\nconst hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nconst compareStringified = (a, b) => stringify(a) === stringify(b);\n\nexport default class IdbImport extends IdbSchema {\n    constructor () {\n        super();\n    }\n    _setup (schema, cb, mergePatch) {\n        const isNUL = schema === '\\0';\n        if (!schema || typeof schema !== 'object' && !(mergePatch && isNUL)) {\n            throw new Error('Bad schema object');\n        }\n        this.addEarlyCallback((e) => {\n            const db = e.target.result;\n            const transaction = e.target.transaction;\n            if (mergePatch && isNUL) {\n                this._deleteAllUnused(db, transaction, {}, true);\n                return;\n            }\n            return cb(e, db, transaction);\n        });\n    }\n    _deleteIndexes (transaction, storeName, exceptionIndexes) {\n        const store = transaction.objectStore(storeName); // Shouldn't throw\n        Array.from(store.indexNames).forEach((indexName) => {\n            if (!exceptionIndexes || !hasOwn(exceptionIndexes, indexName)) {\n                this.delIndex(indexName);\n            }\n        });\n    }\n    _deleteAllUnused (db, transaction, schema, clearUnusedStores, clearUnusedIndexes) {\n        if (clearUnusedStores || clearUnusedIndexes) {\n            Array.from(db.objectStoreNames).forEach((storeName) => {\n                if (clearUnusedStores && !hasOwn(schema, storeName)) {\n                    // Errors for which we are not concerned and why:\n                    // `InvalidStateError` - We are in the upgrade transaction.\n                    // `TransactionInactiveError` (as by the upgrade having already\n                    //      completed or somehow aborting) - since we've just started and\n                    //      should be without risk in this loop\n                    // `NotFoundError` - since we are iterating the dynamically updated\n                    //      `objectStoreNames`\n                    // this._versions[version].dropStores.push({name: storeName});\n                    // Avoid deleting if going to delete in a move/copy\n                    if (!Object.keys(schema).some((key) => [schema[key].moveFrom, schema[key].copyFrom].includes(storeName))) {\n                        this.delStore(storeName); // Shouldn't throw // Keep this and delete previous line if this PR is accepted: https://github.com/treojs/idb-schema/pull/14\n                    }\n                } else if (clearUnusedIndexes) {\n                    this._deleteIndexes(transaction, storeName, schema[storeName].indexes);\n                }\n            });\n        }\n    }\n    _createStoreIfNotSame (db, transaction, schema, storeName, mergePatch) {\n        const newStore = schema[storeName];\n        let store;\n        let storeParams = {};\n        function setCanonicalProps (storeProp) {\n            let canonicalPropValue;\n            if (hasOwn(newStore, 'key')) { // Support old approach of db.js\n                canonicalPropValue = newStore.key[storeProp];\n            } else if (hasOwn(newStore, storeProp)) {\n                canonicalPropValue = newStore[storeProp];\n            } else {\n                canonicalPropValue = storeProp === 'keyPath' ? null : false;\n            }\n            if (mergePatch && typeof canonicalPropValue === 'string') {\n                if (canonicalPropValue === '\\0') {\n                    canonicalPropValue = storeProp === 'keyPath' ? null : false;\n                } else {\n                    canonicalPropValue = canonicalPropValue.replace(/^\\0/, ''); // Remove escape if present\n                }\n            }\n            storeParams[storeProp] = canonicalPropValue;\n        }\n        const copyFrom = newStore.copyFrom;\n        const moveFrom = newStore.moveFrom;\n        try {\n            ['keyPath', 'autoIncrement'].forEach(setCanonicalProps);\n            if (!db.objectStoreNames.contains(storeName)) {\n                throw new Error('goto catch to build store');\n            }\n            store = transaction.objectStore(storeName); // Shouldn't throw\n            this.getStore(store);\n            if (!['keyPath', 'autoIncrement'].every((storeProp) => {\n                return compareStringified(storeParams[storeProp], store[storeProp]);\n            })) {\n                // Avoid deleting if going to delete in a move/copy\n                if (!copyFrom && !moveFrom) this.delStore(storeName);\n                throw new Error('goto catch to build store');\n            }\n        } catch (err) {\n            if (err.message !== 'goto catch to build store') {\n                throw err;\n            }\n            if (copyFrom) {\n                this.copyStore(copyFrom, storeName, storeParams); // May throw\n            } else if (moveFrom) {\n                this.renameStore(moveFrom, storeName, storeParams); // May throw\n            } else {\n                // Errors for which we are not concerned and why:\n                // `InvalidStateError` - We are in the upgrade transaction.\n                // `ConstraintError` - We are just starting (and probably never too large anyways) for a key generator.\n                // `ConstraintError` - The above condition should prevent the name already existing.\n                //\n                // Possible errors:\n                // `TransactionInactiveError` - if the upgrade had already aborted,\n                //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\n                //      the store but then abort the transaction.\n                // `SyntaxError` - if an invalid `storeParams.keyPath` is supplied.\n                // `InvalidAccessError` - if `storeParams.autoIncrement` is `true` and `storeParams.keyPath` is an\n                //      empty string or any sequence (empty or otherwise).\n                this.addStore(storeName, storeParams); // May throw\n            }\n        }\n        return [store, newStore];\n    }\n    _createIndex (store, indexes, indexName, mergePatch) {\n        let newIndex = indexes[indexName];\n        let indexParams = {};\n        function setCanonicalProps (indexProp) {\n            let canonicalPropValue;\n            if (hasOwn(newIndex, indexProp)) {\n                canonicalPropValue = newIndex[indexProp];\n            } else {\n                canonicalPropValue = indexProp === 'keyPath' ? null : false;\n            }\n            if (mergePatch && typeof canonicalPropValue === 'string') {\n                if (canonicalPropValue === '\\0') {\n                    canonicalPropValue = indexProp === 'keyPath' ? null : false;\n                } else {\n                    canonicalPropValue = canonicalPropValue.replace(/^\\0/, ''); // Remove escape if present\n                }\n            }\n            indexParams[indexProp] = canonicalPropValue;\n        }\n        try {\n            ['keyPath', 'unique', 'multiEntry', 'locale'].forEach(setCanonicalProps);\n            if (!store || !store.indexNames.contains(indexName)) {\n                throw new Error('goto catch to build index');\n            }\n            const oldIndex = store.index(indexName);\n            if (!['keyPath', 'unique', 'multiEntry', 'locale'].every((indexProp) => {\n                return compareStringified(indexParams[indexProp], oldIndex[indexProp]);\n            })) {\n                this.delIndex(indexName);\n                throw new Error('goto catch to build index');\n            }\n        } catch (err) {\n            if (err.message !== 'goto catch to build index') {\n                throw err;\n            }\n            // Errors for which we are not concerned and why:\n            // `InvalidStateError` - We are in the upgrade transaction and store found above should not have already been deleted.\n            // `ConstraintError` - We have already tried getting the index, so it shouldn't already exist\n            //\n            // Possible errors:\n            // `TransactionInactiveError` - if the upgrade had already aborted,\n            //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\n            //      the index object but then abort the transaction.\n            // `SyntaxError` - If the `keyPath` (second argument) is an invalid key path\n            // `InvalidAccessError` - If `multiEntry` on `index` is `true` and\n            //                          `keyPath` (second argument) is a sequence\n            this.addIndex(indexName, indexParams.keyPath !== null ? indexParams.keyPath : indexName, indexParams);\n        }\n    }\n    createIdbSchemaPatchSchema (schema) {\n        schema(this); // May throw\n    }\n    // Modified JSON Merge Patch type schemas: https://github.com/json-schema-org/json-schema-spec/issues/15#issuecomment-211142145\n    createMergePatchSchema (schema) {\n        this._setup(schema, (e, db, transaction) => {\n            Object.keys(schema).forEach((storeName) => {\n                const schemaObj = schema[storeName];\n                const isNUL = schemaObj === '\\0';\n                if (isNUL) {\n                    this.delStore(storeName);\n                    return;\n                }\n                if (!schemaObj || typeof schemaObj !== 'object') {\n                    throw new Error('Invalid merge patch schema object (type: ' + typeof schemaObj + '): ' + schemaObj);\n                }\n                const [store] = this._createStoreIfNotSame(db, transaction, schema, storeName, true);\n                if (hasOwn(schemaObj, 'indexes')) {\n                    const indexes = schemaObj.indexes;\n                    const isNUL = indexes === '\\0';\n                    if (isNUL) {\n                        this._deleteIndexes(transaction, storeName);\n                        return;\n                    }\n                    if (!indexes || typeof indexes !== 'object') {\n                        throw new Error('Invalid merge patch indexes object (type: ' + typeof indexes + '): ' + indexes);\n                    }\n                    Object.keys(indexes).forEach((indexName) => {\n                        const indexObj = indexes[indexName];\n                        const isNUL = indexObj === '\\0';\n                        if (isNUL) {\n                            this.delIndex(indexName);\n                            return;\n                        }\n                        if (!indexObj || typeof indexObj !== 'object') {\n                            throw new Error('Invalid merge patch index object (type: ' + typeof indexObj + '): ' + indexObj);\n                        }\n                        this._createIndex(store, indexes, indexName, true);\n                    });\n                }\n            });\n        });\n    }\n    createWholePatchSchema (schema, clearUnusedStores = true, clearUnusedIndexes = true) {\n        this._setup(schema, (e, db, transaction) => {\n            this._deleteAllUnused(db, transaction, schema, clearUnusedStores, clearUnusedIndexes);\n\n            Object.keys(schema).forEach((storeName) => {\n                const [store, newStore] = this._createStoreIfNotSame(db, transaction, schema, storeName);\n                const indexes = newStore.indexes;\n                Object.keys(indexes || {}).forEach((indexName) => {\n                    this._createIndex(store, indexes, indexName);\n                });\n            });\n        });\n    }\n    createVersionedSchema (schemas, schemaType, clearUnusedStores, clearUnusedIndexes) {\n        const createPatches = (schemaObj, schemaType) => {\n            switch (schemaType) {\n            case 'mixed': {\n                schemaObj.forEach((mixedObj) => {\n                    const schemaType = Object.keys(mixedObj)[0];\n                    let schema = mixedObj[schemaType];\n                    if (schemaType !== 'idb-schema' && schema === 'function') {\n                        schema = schema(this); // May throw\n                    }\n                    // These could immediately throw with a bad version\n                    switch (schemaType) {\n                    case 'idb-schema': { // Function called above\n                        this.createIdbSchemaPatchSchema(schema);\n                        break;\n                    }\n                    case 'merge': {\n                        this.createMergePatchSchema(schema);\n                        break;\n                    }\n                    case 'whole': {\n                        this.createWholePatchSchema(schema, clearUnusedStores, clearUnusedIndexes);\n                        break;\n                    }\n                    case 'mixed': {\n                        createPatches(schema, schemaType);\n                        break;\n                    }\n                    default:\n                        throw new Error('Unrecognized schema type');\n                    }\n                });\n                break;\n            }\n            case 'merge': {\n                this.createMergePatchSchema(schemaObj);\n                break;\n            }\n            case 'idb-schema': {\n                this.createIdbSchemaPatchSchema(schemaObj);\n                break;\n            }\n            case 'whole': {\n                this.createWholePatchSchema(schemaObj, clearUnusedStores, clearUnusedIndexes);\n                break;\n            }\n            }\n        };\n        Object.keys(schemas || {}).sort().forEach((schemaVersion) => {\n            const version = parseInt(schemaVersion, 10);\n            let schemaObj = schemas[version];\n            if (schemaType !== 'idb-schema' && typeof schemaObj === 'function') {\n                schemaObj = schemaObj(this); // May throw\n            }\n            this.version(version);\n            createPatches(schemaObj, schemaType, version);\n        });\n    }\n}\n"]}