{"version":3,"sources":["../src/idb-import.js"],"names":[],"mappings":"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","file":"idb-import.js","sourcesContent":["/*\r\nTODOS:\r\n1. JSON Power Patch (including allowing copy/move to preserve store content)\r\n2. Support data within adapted JSON Merge Patch\r\n3. Allow JSON Schema to be specified during import (and export): https://github.com/aaronpowell/db.js/issues/181\r\n4. Support for deleting entire database in various patch types?\r\n*/\r\n\r\nself._babelPolyfill = false; // Need by Phantom in avoiding duplicate babel polyfill error\r\nimport IdbSchema from 'idb-schema';\r\nimport pointer from 'json-pointer';\r\n\r\nconst hasOwn = function (obj, prop) {\r\n    return Object.prototype.hasOwnProperty.call(obj, prop);\r\n};\r\nconst stringify = JSON.stringify;\r\nconst compareStringified = (a, b) => {\r\n    return stringify(a) === stringify(b);\r\n};\r\n\r\nexport default class IdbImport extends IdbSchema {\r\n    constructor () {\r\n        super();\r\n    }\r\n    _setup (schema, version, cb, mergePatch) {\r\n        const isNUL = schema === '\\0';\r\n        if (!schema || typeof schema !== 'object' && !(mergePatch && isNUL)) {\r\n            throw new Error('Bad schema object');\r\n        }\r\n        this.version(version);\r\n        this.addEarlyCallback((e) => {\r\n            const db = e.target.result;\r\n            const transaction = e.target.transaction;\r\n            if (mergePatch && isNUL) {\r\n                this._deleteAllUnused(db, transaction, {}, true);\r\n                return;\r\n            }\r\n            return cb(e, db, transaction);\r\n        });\r\n    }\r\n    _deleteIndexes (transaction, storeName, exceptionIndexes) {\r\n        const store = transaction.objectStore(storeName); // Shouldn't throw\r\n        Array.from(store.indexNames).forEach((indexName) => {\r\n            if (!exceptionIndexes || !hasOwn(exceptionIndexes, indexName)) {\r\n                this.delIndex(indexName);\r\n            }\r\n        });\r\n    }\r\n    _deleteAllUnused (db, transaction, schema, clearUnusedStores, clearUnusedIndexes) {\r\n        if (clearUnusedStores || clearUnusedIndexes) {\r\n            Array.from(db.objectStoreNames).forEach((storeName) => {\r\n                if (clearUnusedStores && !hasOwn(schema, storeName)) {\r\n                    // Errors for which we are not concerned and why:\r\n                    // `InvalidStateError` - We are in the upgrade transaction.\r\n                    // `TransactionInactiveError` (as by the upgrade having already\r\n                    //      completed or somehow aborting) - since we've just started and\r\n                    //      should be without risk in this loop\r\n                    // `NotFoundError` - since we are iterating the dynamically updated\r\n                    //      `objectStoreNames`\r\n                    // this._versions[version].dropStores.push({name: storeName});\r\n                    this.delStore(storeName); // Shouldn't throw // Keep this and delete previous line if this PR is accepted: https://github.com/treojs/idb-schema/pull/14\r\n                } else if (clearUnusedIndexes) {\r\n                    this._deleteIndexes(transaction, storeName, schema[storeName].indexes);\r\n                }\r\n            });\r\n        }\r\n    }\n    _createStoreIfNotSame (db, transaction, schema, storeName, mergePatch) {\r\n        const newStore = schema[storeName];\r\n        let store;\r\n        let storeParams = {};\r\n        function setCanonicalProps (storeProp) {\r\n            let canonicalPropValue;\r\n            if (hasOwn(newStore, 'key')) { // Support old approach of db.js\r\n                canonicalPropValue = newStore.key[storeProp];\r\n            } else if (hasOwn(newStore, storeProp)) {\r\n                canonicalPropValue = newStore[storeProp];\r\n            } else {\r\n                canonicalPropValue = storeProp === 'keyPath' ? null : false;\r\n            }\r\n            if (mergePatch && typeof canonicalPropValue === 'string') {\r\n                if (canonicalPropValue === '\\0') {\r\n                    canonicalPropValue = storeProp === 'keyPath' ? null : false;\r\n                } else {\r\n                    canonicalPropValue = canonicalPropValue.replace(/^\\0/, ''); // Remove escape if present\r\n                }\r\n            }\r\n            storeParams[storeProp] = canonicalPropValue;\r\n            return canonicalPropValue;\r\n        }\r\n        try {\r\n            if (!db.objectStoreNames.contains(storeName)) {\r\n                ['keyPath', 'autoIncrement'].forEach((storeProp) => {\r\n                    setCanonicalProps(storeProp);\r\n                });\r\n                throw new Error('goto catch to build store');\r\n            }\r\n            store = transaction.objectStore(storeName); // Shouldn't throw\r\n            this.getStore(store);\r\n            if (!['keyPath', 'autoIncrement'].every((storeProp) => {\r\n                const canonicalPropValue = setCanonicalProps(storeProp);\r\n                return compareStringified(canonicalPropValue, store[storeProp]);\r\n            })) {\r\n                this.delStore(storeName);\r\n                throw new Error('goto catch to build store');\r\n            }\r\n        } catch (err) {\r\n            if (err.message !== 'goto catch to build store') {\r\n                throw err;\r\n            }\r\n            // Errors for which we are not concerned and why:\r\n            // `InvalidStateError` - We are in the upgrade transaction.\r\n            // `ConstraintError` - We are just starting (and probably never too large anyways) for a key generator.\r\n            // `ConstraintError` - The above condition should prevent the name already existing.\r\n            //\r\n            // Possible errors:\r\n            // `TransactionInactiveError` - if the upgrade had already aborted,\r\n            //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\r\n            //      the store but then abort the transaction.\r\n            // `SyntaxError` - if an invalid `storeParams.keyPath` is supplied.\r\n            // `InvalidAccessError` - if `storeParams.autoIncrement` is `true` and `storeParams.keyPath` is an\r\n            //      empty string or any sequence (empty or otherwise).\r\n            this.addStore(storeName, storeParams); // May throw\r\n        }\r\n        return [store, newStore];\r\n    }\r\n    _createIndex (store, indexes, indexName, mergePatch) {\r\n        let indexObj = indexes[indexName];\r\n        try {\r\n            const oldIndex = store.index(indexName);\r\n\r\n            if (!['keyPath', 'unique', 'multiEntry', 'locale'].every((indexProp) => {\r\n                let canonicalPropValue;\r\n                if (hasOwn(indexObj, indexProp)) {\r\n                    canonicalPropValue = indexObj[indexProp];\r\n                } else {\r\n                    canonicalPropValue = indexProp === 'keyPath' ? null : false;\r\n                }\r\n                if (mergePatch && typeof canonicalPropValue === 'string') {\r\n                    if (canonicalPropValue === '\\0') {\r\n                        canonicalPropValue = indexProp === 'keyPath' ? null : false;\r\n                    } else {\r\n                        canonicalPropValue = canonicalPropValue.replace(/^\\0/, ''); // Remove escape if present\r\n                    }\r\n                }\r\n                return compareStringified(canonicalPropValue, oldIndex[indexProp]);\r\n            })) {\r\n                this.delIndex(indexName);\r\n                throw new Error('goto catch to build index');\r\n            }\r\n        } catch (err) {\r\n            indexObj = indexObj && typeof indexObj === 'object' ? indexObj : {};\r\n            // Errors for which we are not concerned and why:\r\n            // `InvalidStateError` - We are in the upgrade transaction and store found above should not have already been deleted.\r\n            // `ConstraintError` - We have already tried getting the index, so it shouldn't already exist\r\n            //\r\n            // Possible errors:\r\n            // `TransactionInactiveError` - if the upgrade had already aborted,\r\n            //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\r\n            //      the index object but then abort the transaction.\r\n            // `SyntaxError` - If the `keyPath` (second argument) is an invalid key path\r\n            // `InvalidAccessError` - If `multiEntry` on `index` is `true` and\r\n            //                          `keyPath` (second argument) is a sequence\r\n            this.addIndex(indexName, hasOwn(indexObj, 'keyPath') ? indexObj.keyPath : indexObj.key || indexName, indexObj);\r\n        }\r\n    }\r\n    // JSON Power Patch: https://github.com/json-schema-org/json-schema-spec/issues/15#issuecomment-211142145\r\n    createPowerPatchSchema (schema, version) {\r\n        this._setup(schema, version, (e, db, transaction) => {\r\n            Object.keys(schema).forEach((op) => {\r\n                const methodObj = schema[op];\r\n                switch (op) {\r\n                case 'merge': {\r\n                    this.createMergePatchSchema(methodObj, version);\r\n                    break;\r\n                }\r\n                case 'whole': {\r\n                    this.createWholePatchSchema(methodObj, version);\r\n                    break;\r\n                }\r\n                case 'basePaths': {\r\n                    break;\r\n                }\r\n                case 'test': {\r\n                    break;\r\n                }\r\n                case 'remove': {\r\n                    methodObj.forEach((path) => {\r\n                        if (path === '') {\r\n\r\n                        } else {\r\n                            const iter = pointer.parse(path).values();\r\n                            iter.next();\r\n                        }\r\n                    });\r\n                    break;\r\n                }\r\n                case 'add': {\r\n                    break;\r\n                }\r\n                case 'replace': {\r\n                    break;\r\n                }\r\n                case 'move': {\r\n                    break;\r\n                }\r\n                case 'copy': {\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error('Unrecognized JSON PowerPatch method');\r\n                }\r\n                }\r\n            });\r\n        });\r\n        throw new Error('createPowerPatchSchema method not yet implemented!');\r\n    }\r\n    // Modified JSON Merge Patch type schemas: https://github.com/json-schema-org/json-schema-spec/issues/15#issuecomment-211142145\r\n    createMergePatchSchema (schema, version) {\r\n        this._setup(schema, version, (e, db, transaction) => {\r\n            Object.keys(schema).forEach((storeName) => {\r\n                const schemaObj = schema[storeName];\r\n                const isNUL = schemaObj === '\\0';\r\n                if (isNUL) {\r\n                    this.delStore(storeName);\r\n                    return;\r\n                }\r\n                if (!schemaObj || typeof schemaObj !== 'object') {\r\n                    throw new Error('Invalid merge patch schema object (type: ' + typeof schemaObj + '): ' + schemaObj);\r\n                }\r\n                let store;\r\n                if (['key', 'keyPath', 'autoIncrement'].some((prop) => hasOwn(schemaObj, prop))) {\r\n                    [store] = this._createStoreIfNotSame(db, transaction, schema, storeName, true);\r\n                }\r\n                if (hasOwn(schemaObj, 'indexes')) {\r\n                    const indexes = schemaObj.indexes;\r\n                    const isNUL = indexes === '\\0';\r\n                    if (isNUL) {\r\n                        this._deleteIndexes(transaction, storeName);\r\n                        return;\r\n                    }\r\n                    if (!indexes || typeof indexes !== 'object') {\r\n                        throw new Error('Invalid merge patch indexes object (type: ' + typeof indexes + '): ' + indexes);\r\n                    }\r\n                    Object.keys(indexes).forEach((indexName) => {\r\n                        const indexObj = indexes[indexName];\r\n                        const isNUL = indexObj === '\\0';\r\n                        if (isNUL) {\r\n                            this.delIndex(indexName);\r\n                            return;\r\n                        }\r\n                        if (!indexObj || typeof indexObj !== 'object') {\r\n                            throw new Error('Invalid merge patch index object (type: ' + typeof indexObj + '): ' + indexObj);\r\n                        }\r\n                        this._createIndex(store, indexes, indexName, true);\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n    createWholePatchSchema (schema, version, clearUnusedStores = true, clearUnusedIndexes = true) {\r\n        this._setup(schema, version, (e, db, transaction) => {\r\n            this._deleteAllUnused(db, transaction, schema, clearUnusedStores, clearUnusedIndexes);\r\n\r\n            Object.keys(schema).forEach((storeName) => {\n                const [store, newStore] = this._createStoreIfNotSame(db, transaction, schema, storeName);\r\n                const indexes = newStore.indexes;\r\n                Object.keys(indexes || {}).forEach((indexName) => {\r\n                    this._createIndex(store, indexes, indexName);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    createVersionedSchema (schemas, schemaType, clearUnusedStores, clearUnusedIndexes) {\r\n        Object.keys(schemas || {}).sort().forEach((schemaVersion) => {\r\n            const version = parseInt(schemaVersion, 10);\r\n            let schemaObj = schemas[version];\r\n            if (typeof schemaObj === 'function') {\r\n                schemaObj = schemaObj(); // May throw\r\n            }\r\n\r\n            switch (schemaType) {\r\n            case 'mixed': {\r\n                const schemaType = Object.keys(schemaObj)[0];\r\n                let schema = schemaObj[schemaType];\r\n                if (typeof schema === 'function') {\r\n                    schema = schema(); // May throw\r\n                }\r\n                // These could immediately throw with a bad version\r\n                switch (schemaType) {\r\n                case 'power': {\r\n                    this.createPowerPatchSchema(schema, version);\r\n                    break;\r\n                }\r\n                case 'merge': {\r\n                    this.createMergePatchSchema(schema, version);\r\n                    break;\r\n                }\r\n                case 'whole': {\r\n                    this.createWholePatchSchema(schema, version, clearUnusedStores, clearUnusedIndexes);\r\n                    break;\r\n                }\r\n                default:\r\n                    throw new Error('Unrecognized schema type');\r\n                }\r\n                break;\r\n            }\r\n            case 'power': {\r\n                this.createPowerPatchSchema(schemaObj, version);\r\n                break;\r\n            }\r\n            case 'merge': {\r\n                this.createMergePatchSchema(schemaObj, version);\r\n                break;\r\n            }\r\n            case 'whole': {\r\n                this.createWholePatchSchema(schemaObj, version);\r\n                break;\r\n            }\r\n            }\r\n        });\r\n    }\r\n}\r\n"]}