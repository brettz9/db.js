{"version":3,"sources":["../src/idb-import.js"],"names":["self","_babelPolyfill","stringify","JSON","hasOwn","obj","prop","Object","prototype","hasOwnProperty","call","compareStringified","a","b","IdbImport","schema","cb","mergePatch","isNUL","Error","addEarlyCallback","e","db","target","result","transaction","_deleteAllUnused","storeName","exceptionIndexes","store","objectStore","Array","from","indexNames","forEach","indexName","delIndex","clearUnusedStores","clearUnusedIndexes","objectStoreNames","keys","some","key","moveFrom","copyFrom","includes","delStore","_deleteIndexes","indexes","newStore","storeParams","setCanonicalProps","storeProp","canonicalPropValue","replace","contains","getStore","every","err","message","copyStore","renameStore","addStore","newIndex","indexParams","indexProp","oldIndex","index","addIndex","keyPath","_setup","schemaObj","_createStoreIfNotSame","indexObj","_createIndex","schemas","schemaType","createPatches","mixedObj","createIdbSchemaPatchSchema","createMergePatchSchema","createWholePatchSchema","sort","schemaVersion","version","parseInt","IdbSchema"],"mappings":"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","sourcesContent":["/*\r\n# Notes\r\n\r\n1. Could use/adapt [jtlt](https://github.com/brettz9/jtlt/) for changing JSON data\r\n\r\n# Possible to-dos\r\n\r\n1. Support data within adapted JSON Merge Patch\r\n1. Allow JSON Schema to be specified during import (and export): https://github.com/aaronpowell/db.js/issues/181\r\n1. JSON format above database level to allow for deleting or moving/copying of whole databases\r\n1. `copyFrom`/`moveFrom` for indexes\r\n*/\r\n\r\nself._babelPolyfill = false; // Need by Phantom in avoiding duplicate babel polyfill error\r\n\r\n// eslint-disable-next-line import/first\r\nimport IdbSchema from 'idb-schema';\r\n\r\nconst stringify = JSON.stringify;\r\nconst hasOwn = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\r\nconst compareStringified = (a, b) => stringify(a) === stringify(b);\r\n\r\nexport default class IdbImport extends IdbSchema {\r\n    _setup (schema, cb, mergePatch) {\r\n        const isNUL = schema === '\\0';\r\n        if (!schema || (typeof schema !== 'object' && !(mergePatch && isNUL))) {\r\n            throw new Error('Bad schema object');\r\n        }\r\n        this.addEarlyCallback((e) => {\r\n            const db = e.target.result;\r\n            const transaction = e.target.transaction;\r\n            if (mergePatch && isNUL) {\r\n                this._deleteAllUnused(db, transaction, {}, true);\r\n                return;\r\n            }\r\n            return cb(e, db, transaction);\r\n        });\r\n    }\r\n\r\n    _deleteIndexes (transaction, storeName, exceptionIndexes) {\r\n        const store = transaction.objectStore(storeName); // Shouldn't throw\r\n        Array.from(store.indexNames).forEach((indexName) => {\r\n            if (!exceptionIndexes || !hasOwn(exceptionIndexes, indexName)) {\r\n                this.delIndex(indexName);\r\n            }\r\n        });\r\n    }\r\n\r\n    _deleteAllUnused (db, transaction, schema, clearUnusedStores, clearUnusedIndexes) {\r\n        if (clearUnusedStores || clearUnusedIndexes) {\r\n            Array.from(db.objectStoreNames).forEach((storeName) => {\r\n                if (clearUnusedStores && !hasOwn(schema, storeName)) {\r\n                    // Errors for which we are not concerned and why:\r\n                    // `InvalidStateError` - We are in the upgrade transaction.\r\n                    // `TransactionInactiveError` (as by the upgrade having already\r\n                    //      completed or somehow aborting) - since we've just started and\r\n                    //      should be without risk in this loop\r\n                    // `NotFoundError` - since we are iterating the dynamically updated\r\n                    //      `objectStoreNames`\r\n                    // this._versions[version].dropStores.push({name: storeName});\r\n                    // Avoid deleting if going to delete in a move/copy\r\n                    if (!Object.keys(schema).some((key) => [schema[key].moveFrom, schema[key].copyFrom].includes(storeName))) {\r\n                        this.delStore(storeName); // Shouldn't throw // Keep this and delete previous line if this PR is accepted: https://github.com/treojs/idb-schema/pull/14\r\n                    }\r\n                } else if (clearUnusedIndexes) {\r\n                    this._deleteIndexes(transaction, storeName, schema[storeName].indexes);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    _createStoreIfNotSame (db, transaction, schema, storeName, mergePatch) {\r\n        const newStore = schema[storeName];\r\n        let store;\r\n        const storeParams = {};\r\n        function setCanonicalProps (storeProp) {\r\n            let canonicalPropValue;\r\n            if (hasOwn(newStore, 'key')) { // Support old approach of db.js\r\n                canonicalPropValue = newStore.key[storeProp];\r\n            } else if (hasOwn(newStore, storeProp)) {\r\n                canonicalPropValue = newStore[storeProp];\r\n            } else {\r\n                canonicalPropValue = storeProp === 'keyPath' ? null : false;\r\n            }\r\n            if (mergePatch && typeof canonicalPropValue === 'string') {\r\n                if (canonicalPropValue === '\\0') {\r\n                    canonicalPropValue = storeProp === 'keyPath' ? null : false;\r\n                } else {\r\n                    canonicalPropValue = canonicalPropValue.replace(/^\\0/, ''); // Remove escape if present\r\n                }\r\n            }\r\n            storeParams[storeProp] = canonicalPropValue;\r\n        }\r\n        const copyFrom = newStore.copyFrom;\r\n        const moveFrom = newStore.moveFrom;\r\n        try {\r\n            ['keyPath', 'autoIncrement'].forEach(setCanonicalProps);\r\n            if (!db.objectStoreNames.contains(storeName)) {\r\n                throw new Error('goto catch to build store');\r\n            }\r\n            store = transaction.objectStore(storeName); // Shouldn't throw\r\n            this.getStore(store);\r\n            if (!['keyPath', 'autoIncrement'].every((storeProp) => {\r\n                return compareStringified(storeParams[storeProp], store[storeProp]);\r\n            })) {\r\n                // Avoid deleting if going to delete in a move/copy\r\n                if (!copyFrom && !moveFrom) this.delStore(storeName);\r\n                throw new Error('goto catch to build store');\r\n            }\r\n        } catch (err) {\r\n            if (err.message !== 'goto catch to build store') {\r\n                throw err;\r\n            }\r\n            if (copyFrom) {\r\n                this.copyStore(copyFrom, storeName, storeParams); // May throw\r\n            } else if (moveFrom) {\r\n                this.renameStore(moveFrom, storeName, storeParams); // May throw\r\n            } else {\r\n                // Errors for which we are not concerned and why:\r\n                // `InvalidStateError` - We are in the upgrade transaction.\r\n                // `ConstraintError` - We are just starting (and probably never too large anyways) for a key generator.\r\n                // `ConstraintError` - The above condition should prevent the name already existing.\r\n                //\r\n                // Possible errors:\r\n                // `TransactionInactiveError` - if the upgrade had already aborted,\r\n                //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\r\n                //      the store but then abort the transaction.\r\n                // `SyntaxError` - if an invalid `storeParams.keyPath` is supplied.\r\n                // `InvalidAccessError` - if `storeParams.autoIncrement` is `true` and `storeParams.keyPath` is an\r\n                //      empty string or any sequence (empty or otherwise).\r\n                this.addStore(storeName, storeParams); // May throw\r\n            }\r\n        }\r\n        return [store, newStore];\r\n    }\r\n\r\n    _createIndex (store, indexes, indexName, mergePatch) {\r\n        const newIndex = indexes[indexName];\r\n        const indexParams = {};\r\n        function setCanonicalProps (indexProp) {\r\n            let canonicalPropValue;\r\n            if (hasOwn(newIndex, indexProp)) {\r\n                canonicalPropValue = newIndex[indexProp];\r\n            } else {\r\n                canonicalPropValue = indexProp === 'keyPath' ? null : false;\r\n            }\r\n            if (mergePatch && typeof canonicalPropValue === 'string') {\r\n                if (canonicalPropValue === '\\0') {\r\n                    canonicalPropValue = indexProp === 'keyPath' ? null : false;\r\n                } else {\r\n                    canonicalPropValue = canonicalPropValue.replace(/^\\0/, ''); // Remove escape if present\r\n                }\r\n            }\r\n            indexParams[indexProp] = canonicalPropValue;\r\n        }\r\n        try {\r\n            ['keyPath', 'unique', 'multiEntry', 'locale'].forEach(setCanonicalProps);\r\n            if (!store || !store.indexNames.contains(indexName)) {\r\n                throw new Error('goto catch to build index');\r\n            }\r\n            const oldIndex = store.index(indexName);\r\n            if (!['keyPath', 'unique', 'multiEntry', 'locale'].every((indexProp) => {\r\n                return compareStringified(indexParams[indexProp], oldIndex[indexProp]);\r\n            })) {\r\n                this.delIndex(indexName);\r\n                throw new Error('goto catch to build index');\r\n            }\r\n        } catch (err) {\r\n            if (err.message !== 'goto catch to build index') {\r\n                throw err;\r\n            }\r\n            // Errors for which we are not concerned and why:\r\n            // `InvalidStateError` - We are in the upgrade transaction and store found above should not have already been deleted.\r\n            // `ConstraintError` - We have already tried getting the index, so it shouldn't already exist\r\n            //\r\n            // Possible errors:\r\n            // `TransactionInactiveError` - if the upgrade had already aborted,\r\n            //      e.g., from a previous `QuotaExceededError` which is supposed to nevertheless return\r\n            //      the index object but then abort the transaction.\r\n            // `SyntaxError` - If the `keyPath` (second argument) is an invalid key path\r\n            // `InvalidAccessError` - If `multiEntry` on `index` is `true` and\r\n            //                          `keyPath` (second argument) is a sequence\r\n            this.addIndex(indexName, indexParams.keyPath !== null ? indexParams.keyPath : indexName, indexParams);\r\n        }\r\n    }\r\n\r\n    createIdbSchemaPatchSchema (schema) {\r\n        schema(this); // May throw\r\n    }\r\n\r\n    // Modified JSON Merge Patch type schemas: https://github.com/json-schema-org/json-schema-spec/issues/15#issuecomment-211142145\r\n    createMergePatchSchema (schema) {\r\n        this._setup(schema, (e, db, transaction) => {\r\n            Object.keys(schema).forEach((storeName) => {\r\n                const schemaObj = schema[storeName];\r\n                const isNUL = schemaObj === '\\0';\r\n                if (isNUL) {\r\n                    this.delStore(storeName);\r\n                    return;\r\n                }\r\n                if (!schemaObj || typeof schemaObj !== 'object') {\r\n                    throw new Error('Invalid merge patch schema object (type: ' + typeof schemaObj + '): ' + schemaObj);\r\n                }\r\n                const [store] = this._createStoreIfNotSame(db, transaction, schema, storeName, true);\r\n                if (hasOwn(schemaObj, 'indexes')) {\r\n                    const indexes = schemaObj.indexes;\r\n                    const isNUL = indexes === '\\0';\r\n                    if (isNUL) {\r\n                        this._deleteIndexes(transaction, storeName);\r\n                        return;\r\n                    }\r\n                    if (!indexes || typeof indexes !== 'object') {\r\n                        throw new Error('Invalid merge patch indexes object (type: ' + typeof indexes + '): ' + indexes);\r\n                    }\r\n                    Object.keys(indexes).forEach((indexName) => {\r\n                        const indexObj = indexes[indexName];\r\n                        const isNUL = indexObj === '\\0';\r\n                        if (isNUL) {\r\n                            this.delIndex(indexName);\r\n                            return;\r\n                        }\r\n                        if (!indexObj || typeof indexObj !== 'object') {\r\n                            throw new Error('Invalid merge patch index object (type: ' + typeof indexObj + '): ' + indexObj);\r\n                        }\r\n                        this._createIndex(store, indexes, indexName, true);\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    createWholePatchSchema (schema, clearUnusedStores = true, clearUnusedIndexes = true) {\r\n        this._setup(schema, (e, db, transaction) => {\r\n            this._deleteAllUnused(db, transaction, schema, clearUnusedStores, clearUnusedIndexes);\r\n\r\n            Object.keys(schema).forEach((storeName) => {\r\n                const [store, newStore] = this._createStoreIfNotSame(db, transaction, schema, storeName);\r\n                const indexes = newStore.indexes;\r\n                Object.keys(indexes || {}).forEach((indexName) => {\r\n                    this._createIndex(store, indexes, indexName);\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    createVersionedSchema (schemas, schemaType, clearUnusedStores, clearUnusedIndexes) {\r\n        const createPatches = (schemaObj, schemaType) => {\r\n            switch (schemaType) {\r\n            case 'mixed': {\r\n                schemaObj.forEach((mixedObj) => {\r\n                    const schemaType = Object.keys(mixedObj)[0];\r\n                    let schema = mixedObj[schemaType];\r\n                    if (schemaType !== 'idb-schema' && schema === 'function') {\r\n                        schema = schema(this); // May throw\r\n                    }\r\n                    // These could immediately throw with a bad version\r\n                    switch (schemaType) {\r\n                    case 'idb-schema': { // Function called above\r\n                        this.createIdbSchemaPatchSchema(schema);\r\n                        break;\r\n                    }\r\n                    case 'merge': {\r\n                        this.createMergePatchSchema(schema);\r\n                        break;\r\n                    }\r\n                    case 'whole': {\r\n                        this.createWholePatchSchema(schema, clearUnusedStores, clearUnusedIndexes);\r\n                        break;\r\n                    }\r\n                    case 'mixed': {\r\n                        createPatches(schema, schemaType);\r\n                        break;\r\n                    }\r\n                    default:\r\n                        throw new Error('Unrecognized schema type');\r\n                    }\r\n                });\r\n                break;\r\n            }\r\n            case 'merge': {\r\n                this.createMergePatchSchema(schemaObj);\r\n                break;\r\n            }\r\n            case 'idb-schema': {\r\n                this.createIdbSchemaPatchSchema(schemaObj);\r\n                break;\r\n            }\r\n            case 'whole': {\r\n                this.createWholePatchSchema(schemaObj, clearUnusedStores, clearUnusedIndexes);\r\n                break;\r\n            }\r\n            }\r\n        };\r\n        Object.keys(schemas || {}).sort().forEach((schemaVersion) => {\r\n            const version = parseInt(schemaVersion, 10);\r\n            let schemaObj = schemas[version];\r\n            if (schemaType !== 'idb-schema' && typeof schemaObj === 'function') {\r\n                schemaObj = schemaObj(this); // May throw\r\n            }\r\n            this.version(version);\r\n            createPatches(schemaObj, schemaType, version);\r\n        });\r\n    }\r\n}\r\n"],"file":"idb-import.js"}