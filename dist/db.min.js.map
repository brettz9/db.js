{"version":3,"sources":["../src/db.js"],"names":["local","isObject","item","_typeof","mongoDBToKeyRangeArgs","opts","keys","Object","sort","length","key","val","name","inclusive","TypeError","x","y","pattern","mongoifyKey","IDBKeyRange","type","_mongoDBToKeyRangeArg2","apply","_toConsumableArray","args","indexedDB","webkitIndexedDB","mozIndexedDB","oIndexedDB","msIndexedDB","shimIndexedDB","Error","serverEvents","transactionModes","readonly","readwrite","runQuery","cursorType","direction","limitRange","filters","mapper","Promise","resolve","reject","keyRange","results","counter","transaction","trans","db","table","modifyObj","addEventListener","e","store","objectStore","indexArgs","push","modifyRecord","record","modifyKeys","forEach","cursor","target","result","advance","_ret","matchFilter","filter","propObj","_defineProperty","prop","update","err","v","Query","queuedError","defaultMapper","unique","execute","error","count","desc","distinct","limit","map","start","end","some","modify","fn","_this","arguments","this","range","undefined","concat","query","all","closed","setupTransactionAndStore","records","preventDefault","adapterCb","tr","cb","_this2","storeOpsArr","_opts","extraStores","parallel","_idbBatch","transactionalBatch","then","res","ops","_idbBatch2","index","IndexQuery","_key","reduce","aip","req","hasOwn","call","add","onsuccess","keyPath","source","defineProperty","value","enumerable","_key2","put","remove","del","clear","close","dbCache","version","get","eventName","handler","includes","removeEventListener","evName","noServerMethods","Array","from","objectStoreNames","storeName","_open","server","Server","open","options","clearUnusedStores","clearUnusedIndexes","schema","schemas","schemaType","openDb","s","idbimport","_idbImport2","p","_addCallback","addCallback","newCb","schemaBuilder","createVersionedSchema","idbschemaVersion","resume","_retry","retry","dbName","delete","newVersion","Proxy","ev","oldVersion","request","onerror","rej","cmp","param1","param2","module","exports","define","amd"],"mappings":"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","file":"db.min.js","sourcesContent":["import IdbImport from './idb-import';\r\nimport batch, {transactionalBatch} from 'idb-batch';\r\n\r\n(function (local) {\r\n    'use strict';\r\n    const hasOwn = Object.prototype.hasOwnProperty;\r\n\r\n    const indexedDB = local.indexedDB || local.webkitIndexedDB ||\r\n        local.mozIndexedDB || local.oIndexedDB || local.msIndexedDB ||\r\n        local.shimIndexedDB || (function () {\r\n            throw new Error('IndexedDB required');\r\n        }());\r\n    const IDBKeyRange = local.IDBKeyRange || local.webkitIDBKeyRange;\r\n\r\n    const defaultMapper = x => x;\r\n    const serverEvents = ['abort', 'error', 'versionchange'];\r\n    const transactionModes = {\r\n        readonly: 'readonly',\r\n        readwrite: 'readwrite'\r\n    };\r\n\r\n    const dbCache = {};\r\n\r\n    function isObject (item) {\r\n        return item && typeof item === 'object';\r\n    }\r\n\r\n    function mongoDBToKeyRangeArgs (opts) {\r\n        const keys = Object.keys(opts).sort();\r\n        if (keys.length === 1) {\r\n            const key = keys[0];\r\n            const val = opts[key];\r\n            let name, inclusive;\r\n            switch (key) {\r\n            case 'eq': name = 'only'; break;\r\n            case 'gt':\r\n                name = 'lowerBound';\r\n                inclusive = true;\r\n                break;\r\n            case 'lt':\r\n                name = 'upperBound';\r\n                inclusive = true;\r\n                break;\r\n            case 'gte': name = 'lowerBound'; break;\r\n            case 'lte': name = 'upperBound'; break;\r\n            default: throw new TypeError('`' + key + '` is not a valid key');\r\n            }\r\n            return [name, [val, inclusive]];\r\n        }\r\n        const x = opts[keys[0]];\r\n        const y = opts[keys[1]];\r\n        const pattern = keys.join('-');\r\n\r\n        switch (pattern) {\r\n        case 'gt-lt': case 'gt-lte': case 'gte-lt': case 'gte-lte':\r\n            return ['bound', [x, y, keys[0] === 'gt', keys[1] === 'lt']];\r\n        default: throw new TypeError(\r\n          '`' + pattern + '` are conflicted keys'\r\n        );\r\n        }\r\n    }\r\n    function mongoifyKey (key) {\r\n        if (key && typeof key === 'object' && !(key instanceof IDBKeyRange)) {\r\n            const [type, args] = mongoDBToKeyRangeArgs(key);\r\n            return IDBKeyRange[type](...args);\r\n        }\r\n        return key;\r\n    }\r\n\r\n    const IndexQuery = function (table, db, indexName, preexistingError, trans) {\r\n        let modifyObj = null;\r\n\r\n        const runQuery = function (type, args, cursorType, direction, limitRange, filters, mapper) {\r\n            return new Promise(function (resolve, reject) {\r\n                const keyRange = type ? IDBKeyRange[type](...args) : null; // May throw\r\n                filters = filters || [];\r\n                limitRange = limitRange || null;\r\n\r\n                let results = [];\r\n                let counter = 0;\r\n                const indexArgs = [keyRange];\r\n\r\n                const transaction = trans || db.transaction(table, modifyObj ? transactionModes.readwrite : transactionModes.readonly);\r\n                transaction.addEventListener('error', e => reject(e));\r\n                transaction.addEventListener('abort', e => reject(e));\r\n                transaction.addEventListener('complete', () => resolve(results));\r\n\r\n                const store = transaction.objectStore(table); // if bad, db.transaction will reject first\r\n                const index = typeof indexName === 'string' ? store.index(indexName) : store;\r\n\r\n                if (cursorType !== 'count') {\r\n                    indexArgs.push(direction || 'next');\r\n                }\r\n\r\n                // Create a function that will set in the modifyObj properties into\r\n                // the passed record.\r\n                const modifyKeys = modifyObj ? Object.keys(modifyObj) : [];\r\n\r\n                const modifyRecord = function (record) {\r\n                    modifyKeys.forEach(key => {\r\n                        let val = modifyObj[key];\r\n                        if (typeof val === 'function') { val = val(record); }\r\n                        record[key] = val;\r\n                    });\r\n                    return record;\r\n                };\r\n\r\n                index[cursorType](...indexArgs).onsuccess = function (e) { // indexArgs are already validated\r\n                    const cursor = e.target.result;\r\n                    if (typeof cursor === 'number') {\r\n                        results = cursor;\r\n                    } else if (cursor) {\r\n                        if (limitRange !== null && limitRange[0] > counter) {\r\n                            counter = limitRange[0];\r\n                            cursor.advance(limitRange[0]); // Will throw on 0, but condition above prevents since counter always 0+\r\n                        } else if (limitRange !== null && counter >= (limitRange[0] + limitRange[1])) {\r\n                            // Out of limit range... skip\r\n                        } else {\r\n                            let matchFilter = true;\r\n                            let result = 'value' in cursor ? cursor.value : cursor.key;\r\n\r\n                            try { // We must manually catch for this promise as we are within an async event function\r\n                                filters.forEach(function (filter) {\r\n                                    let propObj = filter[0];\r\n                                    if (typeof propObj === 'function') {\r\n                                        matchFilter = matchFilter && propObj(result); // May throw with filter on non-object\r\n                                    } else {\r\n                                        if (!propObj || typeof propObj !== 'object') {\r\n                                            propObj = {[propObj]: filter[1]};\r\n                                        }\r\n                                        Object.keys(propObj).forEach((prop) => {\r\n                                            matchFilter = matchFilter && (result[prop] === propObj[prop]); // May throw with error in filter function\r\n                                        });\r\n                                    }\r\n                                });\r\n\r\n                                if (matchFilter) {\r\n                                    counter++;\r\n                                    // If we're doing a modify, run it now\r\n                                    if (modifyObj) {\r\n                                        result = modifyRecord(result);  // May throw\r\n                                        cursor.update(result); // May throw as `result` should only be a \"structured clone\"-able object\r\n                                    }\r\n                                    results.push(mapper(result)); // May throw\r\n                                }\r\n                            } catch (err) {\r\n                                reject(err);\r\n                                return;\r\n                            }\r\n                            cursor.continue();\r\n                        }\r\n                    }\r\n                };\r\n            });\r\n        };\r\n\r\n        const Query = function (type, args, queuedError) {\r\n            const filters = [];\r\n            let direction = 'next';\r\n            let cursorType = 'openCursor';\r\n            let limitRange = null;\r\n            let mapper = defaultMapper;\r\n            let unique = false;\r\n            let error = preexistingError || queuedError;\r\n\r\n            const execute = function () {\r\n                if (error) {\r\n                    return Promise.reject(error);\r\n                }\r\n                return runQuery(type, args, cursorType, unique ? direction + 'unique' : direction, limitRange, filters, mapper);\r\n            };\r\n\r\n            const count = function () {\r\n                direction = null;\r\n                cursorType = 'count';\r\n                return {execute};\r\n            };\r\n\r\n            const keys = function () {\r\n                cursorType = 'openKeyCursor';\r\n                return {desc, distinct, execute, filter, limit, map};\r\n            };\r\n\r\n            const limit = function (start, end) {\r\n                limitRange = !end ? [0, start] : [start, end];\r\n                error = limitRange.some(val => typeof val !== 'number') ? new Error('limit() arguments must be numeric') : error;\r\n                return {desc, distinct, filter, keys, execute, map, modify};\r\n            };\r\n\r\n            const filter = function (prop, val) {\r\n                filters.push([prop, val]);\r\n                return {desc, distinct, execute, filter, keys, limit, map, modify};\r\n            };\r\n\r\n            const desc = function () {\r\n                direction = 'prev';\r\n                return {distinct, execute, filter, keys, limit, map, modify};\r\n            };\r\n\r\n            const distinct = function () {\r\n                unique = true;\r\n                return {count, desc, execute, filter, keys, limit, map, modify};\r\n            };\r\n\r\n            const modify = function (update) {\r\n                modifyObj = update && typeof update === 'object' ? update : null;\r\n                return {execute};\r\n            };\r\n\r\n            const map = function (fn) {\r\n                mapper = fn;\r\n                return {count, desc, distinct, execute, filter, keys, limit, modify};\r\n            };\r\n\r\n            return {count, desc, distinct, execute, filter, keys, limit, map, modify};\r\n        };\r\n\r\n        ['only', 'bound', 'upperBound', 'lowerBound'].forEach((name) => {\r\n            this[name] = function () {\r\n                return Query(name, arguments);\r\n            };\r\n        });\r\n\r\n        this.range = function (opts) {\r\n            let error;\r\n            let keyRange = [null, null];\r\n            try {\r\n                keyRange = mongoDBToKeyRangeArgs(opts);\r\n            } catch (e) {\r\n                error = e;\r\n            }\r\n            return Query(...keyRange, error);\r\n        };\r\n\r\n        this.filter = function (...args) {\r\n            const query = Query(null, null);\r\n            return query.filter(...args);\r\n        };\r\n\r\n        this.all = function () {\r\n            return this.filter();\r\n        };\r\n    };\r\n\r\n    const Server = function (db, name, version, noServerMethods) {\r\n        let closed = false;\r\n        let trans;\r\n        const setupTransactionAndStore = (db, table, records, resolve, reject, readonly) => {\r\n            const transaction = trans || db.transaction(table, readonly ? transactionModes.readonly : transactionModes.readwrite);\r\n            transaction.addEventListener('error', e => {\r\n                // prevent throwing aborting (hard)\r\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=872873\r\n                e.preventDefault();\r\n                reject(e);\r\n            });\r\n            transaction.addEventListener('abort', e => reject(e));\r\n            transaction.addEventListener('complete', () => resolve(records));\r\n            return transaction.objectStore(table);\r\n        };\r\n        const adapterCb = (tr, cb) => {\r\n            if (!trans) trans = tr;\r\n            return cb(tr, this);\r\n        };\r\n\r\n        this.getIndexedDB = () => db;\r\n        this.isClosed = () => closed;\r\n\r\n        this.batch = function (storeOpsArr, opts = {extraStores: [], parallel: false}) {\r\n            opts = opts || {};\r\n            var {extraStores, parallel} = opts; // We avoid `resolveEarly`\r\n            return transactionalBatch(db, storeOpsArr, {adapterCb, extraStores, parallel}).then((res) => {\r\n                trans = undefined;\r\n                return res;\r\n            });\r\n        };\r\n        this.tableBatch = function (table, ops, opts = {parallel: false}) {\r\n            opts = opts || {};\r\n            return batch(db, table, ops, {adapterCb, parallel: opts.parallel}).then((res) => {\r\n                trans = undefined;\r\n                return res;\r\n            });\r\n        };\r\n\r\n        this.query = function (table, index) {\r\n            const error = closed ? new Error('Database has been closed') : null;\r\n            return new IndexQuery(table, db, index, error, trans); // Does not throw by itself\r\n        };\r\n\r\n        this.add = function (table, ...args) {\r\n            return new Promise(function (resolve, reject) {\r\n                if (closed) {\r\n                    reject(new Error('Database has been closed'));\r\n                    return;\r\n                }\r\n\r\n                const records = args.reduce(function (records, aip) {\r\n                    return records.concat(aip);\r\n                }, []);\r\n\r\n                const store = setupTransactionAndStore(db, table, records, resolve, reject);\r\n\r\n                records.some(function (record) {\r\n                    let req, key;\r\n                    if (isObject(record) && hasOwn.call(record, 'item')) {\r\n                        key = record.key;\r\n                        record = record.item;\r\n                        if (key != null) {\r\n                            key = mongoifyKey(key); // May throw\r\n                        }\r\n                    }\r\n\r\n                    // Safe to add since in readwrite, but may still throw\r\n                    if (key != null) {\r\n                        req = store.add(record, key);\r\n                    } else {\r\n                        req = store.add(record);\r\n                    }\r\n\r\n                    req.onsuccess = function (e) {\r\n                        if (!isObject(record)) {\r\n                            return;\r\n                        }\r\n                        const target = e.target;\r\n                        let keyPath = target.source.keyPath;\r\n                        if (keyPath === null) {\r\n                            keyPath = '__id__';\r\n                        }\r\n                        if (hasOwn.call(record, keyPath)) {\r\n                            return;\r\n                        }\r\n                        Object.defineProperty(record, keyPath, {\r\n                            value: target.result,\r\n                            enumerable: true\r\n                        });\r\n                    };\r\n                });\r\n            });\r\n        };\r\n\r\n        this.update = function (table, ...args) {\r\n            return new Promise(function (resolve, reject) {\r\n                if (closed) {\r\n                    reject(new Error('Database has been closed'));\r\n                    return;\r\n                }\r\n\r\n                const records = args.reduce(function (records, aip) {\r\n                    return records.concat(aip);\r\n                }, []);\r\n\r\n                const store = setupTransactionAndStore(db, table, records, resolve, reject);\r\n\r\n                records.some(function (record) {\r\n                    let req, key;\r\n                    if (isObject(record) && hasOwn.call(record, 'item')) {\r\n                        key = record.key;\r\n                        record = record.item;\r\n                        if (key != null) {\r\n                            key = mongoifyKey(key); // May throw\r\n                        }\r\n                    }\r\n                    // These can throw DataError, e.g., if function passed in\r\n                    if (key != null) {\r\n                        req = store.put(record, key);\r\n                    } else {\r\n                        req = store.put(record);\r\n                    }\r\n\r\n                    req.onsuccess = function (e) {\r\n                        if (!isObject(record)) {\r\n                            return;\r\n                        }\r\n                        const target = e.target;\r\n                        let keyPath = target.source.keyPath;\r\n                        if (keyPath === null) {\r\n                            keyPath = '__id__';\r\n                        }\r\n                        if (hasOwn.call(record, keyPath)) {\r\n                            return;\r\n                        }\r\n                        Object.defineProperty(record, keyPath, {\r\n                            value: target.result,\r\n                            enumerable: true\r\n                        });\r\n                    };\r\n                });\r\n            });\r\n        };\r\n\r\n        this.put = function (...args) {\r\n            return this.update(...args);\r\n        };\r\n\r\n        this.remove = function (table, key) {\r\n            return new Promise(function (resolve, reject) {\r\n                if (closed) {\r\n                    reject(new Error('Database has been closed'));\r\n                    return;\r\n                }\r\n                key = mongoifyKey(key); // May throw\r\n\r\n                const store = setupTransactionAndStore(db, table, key, resolve, reject);\r\n\r\n                store.delete(key); // May throw\r\n            });\r\n        };\r\n\r\n        this.del = this.delete = function (...args) {\r\n            return this.remove(...args);\r\n        };\r\n\r\n        this.clear = function (table) {\r\n            return new Promise(function (resolve, reject) {\r\n                if (closed) {\r\n                    reject(new Error('Database has been closed'));\r\n                    return;\r\n                }\r\n                const store = setupTransactionAndStore(db, table, undefined, resolve, reject);\r\n                store.clear();\r\n            });\r\n        };\r\n\r\n        this.close = function () {\r\n            return new Promise(function (resolve, reject) {\r\n                if (closed) {\r\n                    reject(new Error('Database has been closed'));\r\n                    return;\r\n                }\r\n                closed = true;\r\n                delete dbCache[name][version];\r\n                db.close();\r\n                resolve();\r\n            });\r\n        };\r\n\r\n        this.get = function (table, key) {\r\n            return new Promise(function (resolve, reject) {\r\n                if (closed) {\r\n                    reject(new Error('Database has been closed'));\r\n                    return;\r\n                }\r\n                key = mongoifyKey(key); // May throw\r\n\r\n                const store = setupTransactionAndStore(db, table, undefined, resolve, reject, true);\r\n\r\n                const req = store.get(key);\r\n                req.onsuccess = e => resolve(e.target.result);\r\n            });\r\n        };\r\n\r\n        this.count = function (table, key) {\r\n            return new Promise((resolve, reject) => {\r\n                if (closed) {\r\n                    reject(new Error('Database has been closed'));\r\n                    return;\r\n                }\r\n                key = mongoifyKey(key); // May throw\r\n\r\n                const store = setupTransactionAndStore(db, table, undefined, resolve, reject, true);\r\n\r\n                const req = key == null ? store.count() : store.count(key); // May throw\r\n                req.onsuccess = e => resolve(e.target.result);\r\n            });\r\n        };\r\n\r\n        this.addEventListener = function (eventName, handler) {\r\n            if (!serverEvents.includes(eventName)) {\r\n                throw new Error('Unrecognized event type ' + eventName);\r\n            }\r\n            if (eventName === 'error') {\r\n                db.addEventListener(eventName, function (e) {\r\n                    e.preventDefault(); // Needed to prevent hard abort with ConstraintError\r\n                    handler(e);\r\n                });\r\n                return;\r\n            }\r\n            db.addEventListener(eventName, handler);\r\n        };\r\n\r\n        this.removeEventListener = function (eventName, handler) {\r\n            if (!serverEvents.includes(eventName)) {\r\n                throw new Error('Unrecognized event type ' + eventName);\r\n            }\r\n            db.removeEventListener(eventName, handler);\r\n        };\r\n\r\n        serverEvents.forEach(function (evName) {\r\n            this[evName] = function (handler) {\r\n                this.addEventListener(evName, handler);\r\n                return this;\r\n            };\r\n        }, this);\r\n\r\n        if (noServerMethods) {\r\n            return;\r\n        }\r\n\r\n        let err;\r\n        Array.from(db.objectStoreNames).some(storeName => {\r\n            if (this[storeName]) {\r\n                err = new Error('The store name, \"' + storeName + '\", which you have attempted to load, conflicts with db.js method names.\"');\r\n                this.close();\r\n                return true;\r\n            }\r\n            this[storeName] = {};\r\n            const keys = Object.keys(this);\r\n            keys.filter(key => !(([...serverEvents, 'close', 'batch', 'addEventListener', 'removeEventListener']).includes(key)))\r\n                .map(key => {\r\n                    this[storeName][key] = (...args) => this[key](storeName, ...args);\r\n                });\r\n        });\r\n        return err;\r\n    };\r\n\r\n    const open = function (db, server, version, noServerMethods) {\r\n        dbCache[server][version] = db;\r\n\r\n        return new Server(db, server, version, noServerMethods);\r\n    };\r\n\r\n    const db = {\r\n        version: '0.15.0',\r\n        open: function (options) {\r\n            const server = options.server;\r\n            const noServerMethods = options.noServerMethods;\r\n            const clearUnusedStores = options.clearUnusedStores !== false;\r\n            const clearUnusedIndexes = options.clearUnusedIndexes !== false;\r\n            let version = options.version || 1;\r\n            let schema = options.schema;\r\n            let schemas = options.schemas;\r\n            let schemaType = options.schemaType || (schema ? 'whole' : 'mixed');\r\n            if (!dbCache[server]) {\r\n                dbCache[server] = {};\r\n            }\r\n            const openDb = function (db) {\r\n                const s = open(db, server, version, noServerMethods);\r\n                if (s instanceof Error) {\r\n                    throw s;\r\n                }\r\n                return s;\r\n            };\r\n\r\n            return new Promise(function (resolve, reject) {\r\n                if (dbCache[server][version]) {\r\n                    const s = open(dbCache[server][version], server, version, noServerMethods);\r\n                    if (s instanceof Error) {\r\n                        reject(s);\r\n                        return;\r\n                    }\r\n                    resolve(s);\r\n                    return;\r\n                }\r\n                const idbimport = new IdbImport();\r\n                let p = Promise.resolve();\r\n                if (schema || schemas || options.schemaBuilder) {\r\n                    const _addCallback = idbimport.addCallback;\r\n                    idbimport.addCallback = function (cb) {\r\n                        function newCb (db) {\r\n                            const s = open(db, server, version, noServerMethods);\r\n                            if (s instanceof Error) {\r\n                                throw s;\r\n                            }\r\n                            return cb(db, s);\r\n                        }\r\n                        return _addCallback.call(idbimport, newCb);\r\n                    };\r\n\r\n                    p = p.then(() => {\r\n                        if (options.schemaBuilder) {\r\n                            return options.schemaBuilder(idbimport);\r\n                        }\r\n                    }).then(() => {\r\n                        if (schema) {\r\n                            switch (schemaType) {\r\n                            case 'mixed': case 'idb-schema': case 'merge': case 'whole': {\r\n                                schemas = {[version]: schema};\r\n                                break;\r\n                            }\r\n                            }\r\n                        }\r\n                        if (schemas) {\r\n                            idbimport.createVersionedSchema(schemas, schemaType, clearUnusedStores, clearUnusedIndexes);\r\n                        }\r\n                        const idbschemaVersion = idbimport.version();\r\n                        if (options.version && idbschemaVersion < version) {\r\n                            throw new Error(\r\n                                'Your highest schema building (IDBSchema) version (' + idbschemaVersion + ') ' +\r\n                                'must not be less than your designated version (' + version + ').'\r\n                            );\r\n                        }\r\n                        if (!options.version && idbschemaVersion > version) {\r\n                            version = idbschemaVersion;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                p.then(() => {\r\n                    return idbimport.open(server, version);\r\n                }).catch((err) => {\r\n                    if (err.resume) {\r\n                        err.resume = err.resume.then(openDb);\r\n                    }\r\n                    if (err.retry) {\r\n                        const _retry = err.retry;\r\n                        err.retry = function () {\r\n                            _retry.call(err).then(openDb);\r\n                        };\r\n                    }\r\n                    throw err;\r\n                }).then(openDb).then(resolve).catch((e) => {\r\n                    reject(e);\r\n                });\r\n            });\r\n        },\r\n\r\n        del: function (dbName) {\r\n            return this.delete(dbName);\r\n        },\r\n        delete: function (dbName) {\r\n            return new Promise(function (resolve, reject) {\r\n                const request = indexedDB.deleteDatabase(dbName); // Does not throw\r\n\r\n                request.onsuccess = e => {\r\n                    // The following is needed currently by PhantomJS (though we cannot polyfill `oldVersion`): https://github.com/ariya/phantomjs/issues/14141\r\n                    if (!('newVersion' in e)) {\r\n                        e.newVersion = null;\r\n                    }\r\n                    resolve(e);\r\n                };\r\n                request.onerror = e => { // No errors currently\r\n                    e.preventDefault();\r\n                    reject(e);\r\n                };\r\n                request.onblocked = e => {\r\n                    // The following addresses part of https://bugzilla.mozilla.org/show_bug.cgi?id=1220279\r\n                    e = e.newVersion === null || typeof Proxy === 'undefined' ? e : new Proxy(e, {get: function (target, name) {\r\n                        return name === 'newVersion' ? null : target[name];\r\n                    }});\r\n                    const resume = new Promise(function (res, rej) {\r\n                        // We overwrite handlers rather than make a new\r\n                        //   delete() since the original request is still\r\n                        //   open and its onsuccess will still fire if\r\n                        //   the user unblocks by closing the blocking\r\n                        //   connection\r\n                        request.onsuccess = ev => {\r\n                            // The following are needed currently by PhantomJS: https://github.com/ariya/phantomjs/issues/14141\r\n                            if (!('newVersion' in ev)) {\r\n                                ev.newVersion = e.newVersion;\r\n                            }\r\n\r\n                            if (!('oldVersion' in ev)) {\r\n                                ev.oldVersion = e.oldVersion;\r\n                            }\r\n\r\n                            res(ev);\r\n                        };\r\n                        request.onerror = e => {\r\n                            e.preventDefault();\r\n                            rej(e);\r\n                        };\r\n                    });\r\n                    e.resume = resume;\r\n                    reject(e);\r\n                };\r\n            });\r\n        },\r\n\r\n        cmp: function (param1, param2) {\r\n            return new Promise(function (resolve, reject) {\r\n                resolve(indexedDB.cmp(param1, param2)); // May throw\r\n            });\r\n        }\r\n    };\r\n\r\n    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\r\n        module.exports = db;\r\n    } else if (typeof define === 'function' && define.amd) {\r\n        define(function () { return db; });\r\n    } else {\r\n        local.db = db;\r\n    }\r\n}(self));\r\n"]}