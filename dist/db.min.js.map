{"version":3,"sources":["../src/db.js"],"names":["local","isObject","item","_typeof","keys","opts","length","sort","key","val","name","inclusive","TypeError","y","pattern","x","mongoDBToKeyRangeArgs","IDBKeyRange","_mongoDBToKeyRangeArg","type","_slicedToArray","args","_mongoDBToKeyRangeArg2","apply","_toConsumableArray","indexedDB","Error","webkitIndexedDB","mozIndexedDB","oIndexedDB","msIndexedDB","shimIndexedDB","defaultMapper","transactionModes","readonly","readwrite","IndexQuery","table","db","indexName","preexistingError","trans","runQuery","Promise","resolve","reject","direction","limitRange","filters","mapper","keyRange","counter","indexArgs","transaction","addEventListener","modifyObj","e","results","index","push","modifyKeys","forEach","record","cursorType","onsuccess","cursor","result","advance","propObj","filter","matchFilter","_defineProperty","prop","update","err","Query","queuedError","unique","error","execute","desc","distinct","limit","map","start","end","some","modify","count","fn","_this","arguments","this","range","undefined","concat","query","all","Server","version","noServerMethods","setupTransactionAndStore","records","objectStore","adapterCb","tr","cb","_this2","getIndexedDB","isClosed","closed","batch","storeOpsArr","extraStores","parallel","_opts","transactionalBatch","then","res","tableBatch","ops","add","_len","Array","_key","aip","req","hasOwn","call","mongoifyKey","store","keyPath","target","source","value","enumerable","_len2","_key2","put","remove","del","clear","close","dbCache","get","includes","eventName","handler","serverEvents","removeEventListener","evName","from","objectStoreNames","storeName","Object","_len3","_key3","server","open","options","clearUnusedStores","clearUnusedIndexes","schema","schemas","schemaType","openDb","s","p","_addCallback","idbimport","addCallback","newCb","schemaBuilder","createVersionedSchema","idbschemaVersion","catch","resume","_retry","retry","delete","dbName","request","deleteDatabase","newVersion","onerror","onblocked","Proxy","rej","ev","oldVersion","preventDefault","cmp","param2","param1","rangeIncludes","exports","module","define","amd"],"mappings":"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","file":"db.min.js","sourcesContent":["import IdbImport from './idb-import';\nimport batch, {transactionalBatch} from 'idb-batch';\n\n(function (local) {\n    'use strict';\n    const hasOwn = Object.prototype.hasOwnProperty;\n\n    const indexedDB = local.indexedDB || local.webkitIndexedDB ||\n        local.mozIndexedDB || local.oIndexedDB || local.msIndexedDB ||\n        local.shimIndexedDB || (function () {\n            throw new Error('IndexedDB required');\n        }());\n    const IDBKeyRange = local.IDBKeyRange || local.webkitIDBKeyRange;\n\n    const defaultMapper = x => x;\n    const serverEvents = ['abort', 'error', 'versionchange'];\n    const transactionModes = {\n        readonly: 'readonly',\n        readwrite: 'readwrite'\n    };\n\n    const dbCache = {};\n\n    function isObject (item) {\n        return item && typeof item === 'object';\n    }\n\n    function mongoDBToKeyRangeArgs (opts) {\n        const keys = Object.keys(opts).sort();\n        if (keys.length === 1) {\n            const key = keys[0];\n            const val = opts[key];\n            let name, inclusive;\n            switch (key) {\n            case 'eq': name = 'only'; break;\n            case 'gt':\n                name = 'lowerBound';\n                inclusive = true;\n                break;\n            case 'lt':\n                name = 'upperBound';\n                inclusive = true;\n                break;\n            case 'gte': name = 'lowerBound'; break;\n            case 'lte': name = 'upperBound'; break;\n            default: throw new TypeError('`' + key + '` is not a valid key');\n            }\n            return [name, [val, inclusive]];\n        }\n        const x = opts[keys[0]];\n        const y = opts[keys[1]];\n        const pattern = keys.join('-');\n\n        switch (pattern) {\n        case 'gt-lt': case 'gt-lte': case 'gte-lt': case 'gte-lte':\n            return ['bound', [x, y, keys[0] === 'gt', keys[1] === 'lt']];\n        default: throw new TypeError(\n          '`' + pattern + '` are conflicted keys'\n        );\n        }\n    }\n    function mongoifyKey (key) {\n        if (key && typeof key === 'object' && !(key instanceof IDBKeyRange)) {\n            const [type, args] = mongoDBToKeyRangeArgs(key);\n            return IDBKeyRange[type](...args);\n        }\n        return key;\n    }\n\n    const IndexQuery = function (table, db, indexName, preexistingError, trans) {\n        let modifyObj = null;\n\n        const runQuery = function (type, args, cursorType, direction, limitRange, filters, mapper) {\n            return new Promise(function (resolve, reject) {\n                const keyRange = type ? IDBKeyRange[type](...args) : null; // May throw\n                filters = filters || [];\n                limitRange = limitRange || null;\n\n                let results = [];\n                let counter = 0;\n                const indexArgs = [keyRange];\n\n                const transaction = trans || db.transaction(table, modifyObj ? transactionModes.readwrite : transactionModes.readonly);\n                transaction.addEventListener('error', e => reject(e));\n                transaction.addEventListener('abort', e => reject(e));\n                transaction.addEventListener('complete', () => resolve(results));\n\n                const store = transaction.objectStore(table); // if bad, db.transaction will reject first\n                const index = typeof indexName === 'string' ? store.index(indexName) : store;\n\n                if (cursorType !== 'count') {\n                    indexArgs.push(direction || 'next');\n                }\n\n                // Create a function that will set in the modifyObj properties into\n                // the passed record.\n                const modifyKeys = modifyObj ? Object.keys(modifyObj) : [];\n\n                const modifyRecord = function (record) {\n                    modifyKeys.forEach(key => {\n                        let val = modifyObj[key];\n                        if (typeof val === 'function') { val = val(record); }\n                        record[key] = val;\n                    });\n                    return record;\n                };\n\n                index[cursorType](...indexArgs).onsuccess = function (e) { // indexArgs are already validated\n                    const cursor = e.target.result;\n                    if (typeof cursor === 'number') {\n                        results = cursor;\n                    } else if (cursor) {\n                        if (limitRange !== null && limitRange[0] > counter) {\n                            counter = limitRange[0];\n                            cursor.advance(limitRange[0]); // Will throw on 0, but condition above prevents since counter always 0+\n                        } else if (limitRange !== null && counter >= (limitRange[0] + limitRange[1])) {\n                            // Out of limit range... skip\n                        } else {\n                            let matchFilter = true;\n                            let result = 'value' in cursor ? cursor.value : cursor.key;\n\n                            try { // We must manually catch for this promise as we are within an async event function\n                                filters.forEach(function (filter) {\n                                    let propObj = filter[0];\n                                    if (typeof propObj === 'function') {\n                                        matchFilter = matchFilter && propObj(result); // May throw with filter on non-object\n                                    } else {\n                                        if (!propObj || typeof propObj !== 'object') {\n                                            propObj = {[propObj]: filter[1]};\n                                        }\n                                        Object.keys(propObj).forEach((prop) => {\n                                            matchFilter = matchFilter && (result[prop] === propObj[prop]); // May throw with error in filter function\n                                        });\n                                    }\n                                });\n\n                                if (matchFilter) {\n                                    counter++;\n                                    // If we're doing a modify, run it now\n                                    if (modifyObj) {\n                                        result = modifyRecord(result);  // May throw\n                                        cursor.update(result); // May throw as `result` should only be a \"structured clone\"-able object\n                                    }\n                                    results.push(mapper(result)); // May throw\n                                }\n                            } catch (err) {\n                                reject(err);\n                                return;\n                            }\n                            cursor.continue();\n                        }\n                    }\n                };\n            });\n        };\n\n        const Query = function (type, args, queuedError) {\n            const filters = [];\n            let direction = 'next';\n            let cursorType = 'openCursor';\n            let limitRange = null;\n            let mapper = defaultMapper;\n            let unique = false;\n            let error = preexistingError || queuedError;\n\n            const execute = function () {\n                if (error) {\n                    return Promise.reject(error);\n                }\n                return runQuery(type, args, cursorType, unique ? direction + 'unique' : direction, limitRange, filters, mapper);\n            };\n\n            const count = function () {\n                direction = null;\n                cursorType = 'count';\n                return {execute};\n            };\n\n            const keys = function () {\n                cursorType = 'openKeyCursor';\n                return {desc, distinct, execute, filter, limit, map};\n            };\n\n            const limit = function (start, end) {\n                limitRange = !end ? [0, start] : [start, end];\n                error = limitRange.some(val => typeof val !== 'number') ? new Error('limit() arguments must be numeric') : error;\n                return {desc, distinct, filter, keys, execute, map, modify};\n            };\n\n            const filter = function (prop, val) {\n                filters.push([prop, val]);\n                return {desc, distinct, execute, filter, keys, limit, map, modify};\n            };\n\n            const desc = function () {\n                direction = 'prev';\n                return {distinct, execute, filter, keys, limit, map, modify};\n            };\n\n            const distinct = function () {\n                unique = true;\n                return {count, desc, execute, filter, keys, limit, map, modify};\n            };\n\n            const modify = function (update) {\n                modifyObj = update && typeof update === 'object' ? update : null;\n                return {execute};\n            };\n\n            const map = function (fn) {\n                mapper = fn;\n                return {count, desc, distinct, execute, filter, keys, limit, modify};\n            };\n\n            return {count, desc, distinct, execute, filter, keys, limit, map, modify};\n        };\n\n        ['only', 'bound', 'upperBound', 'lowerBound'].forEach((name) => {\n            this[name] = function () {\n                return Query(name, arguments);\n            };\n        });\n\n        this.range = function (opts) {\n            let error;\n            let keyRange = [null, null];\n            try {\n                keyRange = mongoDBToKeyRangeArgs(opts);\n            } catch (e) {\n                error = e;\n            }\n            return Query(...keyRange, error);\n        };\n\n        this.filter = function (...args) {\n            const query = Query(null, null);\n            return query.filter(...args);\n        };\n\n        this.all = function () {\n            return this.filter();\n        };\n    };\n\n    const Server = function (db, name, version, noServerMethods) {\n        let closed = false;\n        let trans;\n        const setupTransactionAndStore = (db, table, records, resolve, reject, readonly) => {\n            const transaction = trans || db.transaction(table, readonly ? transactionModes.readonly : transactionModes.readwrite);\n            transaction.addEventListener('error', e => {\n                // prevent throwing aborting (hard)\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=872873\n                e.preventDefault();\n                reject(e);\n            });\n            transaction.addEventListener('abort', e => reject(e));\n            transaction.addEventListener('complete', () => resolve(records));\n            return transaction.objectStore(table);\n        };\n        const adapterCb = (tr, cb) => {\n            if (!trans) trans = tr;\n            return cb(tr, this);\n        };\n\n        this.getIndexedDB = () => db;\n        this.isClosed = () => closed;\n\n        this.batch = function (storeOpsArr, opts = {extraStores: [], parallel: false}) {\n            opts = opts || {};\n            var {extraStores, parallel} = opts; // We avoid `resolveEarly`\n            return transactionalBatch(db, storeOpsArr, {adapterCb, extraStores, parallel}).then((res) => {\n                trans = undefined;\n                return res;\n            });\n        };\n        this.tableBatch = function (table, ops, opts = {parallel: false}) {\n            opts = opts || {};\n            return batch(db, table, ops, {adapterCb, parallel: opts.parallel}).then((res) => {\n                trans = undefined;\n                return res;\n            });\n        };\n\n        this.query = function (table, index) {\n            const error = closed ? new Error('Database has been closed') : null;\n            return new IndexQuery(table, db, index, error, trans); // Does not throw by itself\n        };\n\n        this.add = function (table, ...args) {\n            return new Promise(function (resolve, reject) {\n                if (closed) {\n                    reject(new Error('Database has been closed'));\n                    return;\n                }\n\n                const records = args.reduce(function (records, aip) {\n                    return records.concat(aip);\n                }, []);\n\n                const store = setupTransactionAndStore(db, table, records, resolve, reject);\n\n                records.some(function (record) {\n                    let req, key;\n                    if (isObject(record) && hasOwn.call(record, 'item')) {\n                        key = record.key;\n                        record = record.item;\n                        if (key != null) {\n                            key = mongoifyKey(key); // May throw\n                        }\n                    }\n\n                    // Safe to add since in readwrite, but may still throw\n                    if (key != null) {\n                        req = store.add(record, key);\n                    } else {\n                        req = store.add(record);\n                    }\n\n                    req.onsuccess = function (e) {\n                        if (!isObject(record)) {\n                            return;\n                        }\n                        const target = e.target;\n                        let keyPath = target.source.keyPath;\n                        if (keyPath === null) {\n                            keyPath = '__id__';\n                        }\n                        if (hasOwn.call(record, keyPath)) {\n                            return;\n                        }\n                        Object.defineProperty(record, keyPath, {\n                            value: target.result,\n                            enumerable: true\n                        });\n                    };\n                });\n            });\n        };\n\n        this.update = function (table, ...args) {\n            return new Promise(function (resolve, reject) {\n                if (closed) {\n                    reject(new Error('Database has been closed'));\n                    return;\n                }\n\n                const records = args.reduce(function (records, aip) {\n                    return records.concat(aip);\n                }, []);\n\n                const store = setupTransactionAndStore(db, table, records, resolve, reject);\n\n                records.some(function (record) {\n                    let req, key;\n                    if (isObject(record) && hasOwn.call(record, 'item')) {\n                        key = record.key;\n                        record = record.item;\n                        if (key != null) {\n                            key = mongoifyKey(key); // May throw\n                        }\n                    }\n                    // These can throw DataError, e.g., if function passed in\n                    if (key != null) {\n                        req = store.put(record, key);\n                    } else {\n                        req = store.put(record);\n                    }\n\n                    req.onsuccess = function (e) {\n                        if (!isObject(record)) {\n                            return;\n                        }\n                        const target = e.target;\n                        let keyPath = target.source.keyPath;\n                        if (keyPath === null) {\n                            keyPath = '__id__';\n                        }\n                        if (hasOwn.call(record, keyPath)) {\n                            return;\n                        }\n                        Object.defineProperty(record, keyPath, {\n                            value: target.result,\n                            enumerable: true\n                        });\n                    };\n                });\n            });\n        };\n\n        this.put = function (...args) {\n            return this.update(...args);\n        };\n\n        this.remove = function (table, key) {\n            return new Promise(function (resolve, reject) {\n                if (closed) {\n                    reject(new Error('Database has been closed'));\n                    return;\n                }\n                key = mongoifyKey(key); // May throw\n\n                const store = setupTransactionAndStore(db, table, key, resolve, reject);\n\n                store.delete(key); // May throw\n            });\n        };\n\n        this.del = this.delete = function (...args) {\n            return this.remove(...args);\n        };\n\n        this.clear = function (table) {\n            return new Promise(function (resolve, reject) {\n                if (closed) {\n                    reject(new Error('Database has been closed'));\n                    return;\n                }\n                const store = setupTransactionAndStore(db, table, undefined, resolve, reject);\n                store.clear();\n            });\n        };\n\n        this.close = function () {\n            return new Promise(function (resolve, reject) {\n                if (closed) {\n                    reject(new Error('Database has been closed'));\n                    return;\n                }\n                closed = true;\n                delete dbCache[name][version];\n                db.close();\n                resolve();\n            });\n        };\n\n        this.get = function (table, key) {\n            return new Promise(function (resolve, reject) {\n                if (closed) {\n                    reject(new Error('Database has been closed'));\n                    return;\n                }\n                key = mongoifyKey(key); // May throw\n\n                const store = setupTransactionAndStore(db, table, undefined, resolve, reject, true);\n\n                const req = store.get(key);\n                req.onsuccess = e => resolve(e.target.result);\n            });\n        };\n\n        this.count = function (table, key) {\n            return new Promise((resolve, reject) => {\n                if (closed) {\n                    reject(new Error('Database has been closed'));\n                    return;\n                }\n                key = mongoifyKey(key); // May throw\n\n                const store = setupTransactionAndStore(db, table, undefined, resolve, reject, true);\n\n                const req = key == null ? store.count() : store.count(key); // May throw\n                req.onsuccess = e => resolve(e.target.result);\n            });\n        };\n\n        this.addEventListener = function (eventName, handler) {\n            if (!serverEvents.includes(eventName)) {\n                throw new Error('Unrecognized event type ' + eventName);\n            }\n            if (eventName === 'error') {\n                db.addEventListener(eventName, function (e) {\n                    e.preventDefault(); // Needed to prevent hard abort with ConstraintError\n                    handler(e);\n                });\n                return;\n            }\n            db.addEventListener(eventName, handler);\n        };\n\n        this.removeEventListener = function (eventName, handler) {\n            if (!serverEvents.includes(eventName)) {\n                throw new Error('Unrecognized event type ' + eventName);\n            }\n            db.removeEventListener(eventName, handler);\n        };\n\n        serverEvents.forEach(function (evName) {\n            this[evName] = function (handler) {\n                this.addEventListener(evName, handler);\n                return this;\n            };\n        }, this);\n\n        if (noServerMethods) {\n            return;\n        }\n\n        let err;\n        Array.from(db.objectStoreNames).some(storeName => {\n            if (this[storeName]) {\n                err = new Error('The store name, \"' + storeName + '\", which you have attempted to load, conflicts with db.js method names.\"');\n                this.close();\n                return true;\n            }\n            this[storeName] = {};\n            const keys = Object.keys(this);\n            keys.filter(key => !(([...serverEvents, 'close', 'batch', 'addEventListener', 'removeEventListener']).includes(key)))\n                .map(key => {\n                    this[storeName][key] = (...args) => this[key](storeName, ...args);\n                });\n        });\n        return err;\n    };\n\n    const open = function (db, server, version, noServerMethods) {\n        dbCache[server][version] = db;\n\n        return new Server(db, server, version, noServerMethods);\n    };\n\n    const db = {\n        version: '0.15.0',\n        open: function (options) {\n            const server = options.server;\n            const noServerMethods = options.noServerMethods;\n            const clearUnusedStores = options.clearUnusedStores !== false;\n            const clearUnusedIndexes = options.clearUnusedIndexes !== false;\n            let version = options.version || 1;\n            let schema = options.schema;\n            let schemas = options.schemas;\n            let schemaType = options.schemaType || (schema ? 'whole' : 'mixed');\n            if (!dbCache[server]) {\n                dbCache[server] = {};\n            }\n            const openDb = function (db) {\n                const s = open(db, server, version, noServerMethods);\n                if (s instanceof Error) {\n                    throw s;\n                }\n                return s;\n            };\n\n            return new Promise(function (resolve, reject) {\n                if (dbCache[server][version]) {\n                    const s = open(dbCache[server][version], server, version, noServerMethods);\n                    if (s instanceof Error) {\n                        reject(s);\n                        return;\n                    }\n                    resolve(s);\n                    return;\n                }\n                const idbimport = new IdbImport();\n                let p = Promise.resolve();\n                if (schema || schemas || options.schemaBuilder) {\n                    const _addCallback = idbimport.addCallback;\n                    idbimport.addCallback = function (cb) {\n                        function newCb (db) {\n                            const s = open(db, server, version, noServerMethods);\n                            if (s instanceof Error) {\n                                throw s;\n                            }\n                            return cb(db, s);\n                        }\n                        return _addCallback.call(idbimport, newCb);\n                    };\n\n                    p = p.then(() => {\n                        if (options.schemaBuilder) {\n                            return options.schemaBuilder(idbimport);\n                        }\n                    }).then(() => {\n                        if (schema) {\n                            switch (schemaType) {\n                            case 'mixed': case 'idb-schema': case 'merge': case 'whole': {\n                                schemas = {[version]: schema};\n                                break;\n                            }\n                            }\n                        }\n                        if (schemas) {\n                            idbimport.createVersionedSchema(schemas, schemaType, clearUnusedStores, clearUnusedIndexes);\n                        }\n                        const idbschemaVersion = idbimport.version();\n                        if (options.version && idbschemaVersion < version) {\n                            throw new Error(\n                                'Your highest schema building (IDBSchema) version (' + idbschemaVersion + ') ' +\n                                'must not be less than your designated version (' + version + ').'\n                            );\n                        }\n                        if (!options.version && idbschemaVersion > version) {\n                            version = idbschemaVersion;\n                        }\n                    });\n                }\n\n                p.then(() => {\n                    return idbimport.open(server, version);\n                }).catch((err) => {\n                    if (err.resume) {\n                        err.resume = err.resume.then(openDb);\n                    }\n                    if (err.retry) {\n                        const _retry = err.retry;\n                        err.retry = function () {\n                            _retry.call(err).then(openDb);\n                        };\n                    }\n                    throw err;\n                }).then(openDb).then(resolve).catch((e) => {\n                    reject(e);\n                });\n            });\n        },\n\n        del: function (dbName) {\n            return this.delete(dbName);\n        },\n        delete: function (dbName) {\n            return new Promise(function (resolve, reject) {\n                const request = indexedDB.deleteDatabase(dbName); // Does not throw\n\n                request.onsuccess = e => {\n                    // The following is needed currently by PhantomJS (though we cannot polyfill `oldVersion`): https://github.com/ariya/phantomjs/issues/14141\n                    if (!('newVersion' in e)) {\n                        e.newVersion = null;\n                    }\n                    resolve(e);\n                };\n                request.onerror = e => { // No errors currently\n                    e.preventDefault();\n                    reject(e);\n                };\n                request.onblocked = e => {\n                    // The following addresses part of https://bugzilla.mozilla.org/show_bug.cgi?id=1220279\n                    e = e.newVersion === null || typeof Proxy === 'undefined' ? e : new Proxy(e, {get: function (target, name) {\n                        return name === 'newVersion' ? null : target[name];\n                    }});\n                    const resume = new Promise(function (res, rej) {\n                        // We overwrite handlers rather than make a new\n                        //   delete() since the original request is still\n                        //   open and its onsuccess will still fire if\n                        //   the user unblocks by closing the blocking\n                        //   connection\n                        request.onsuccess = ev => {\n                            // The following are needed currently by PhantomJS: https://github.com/ariya/phantomjs/issues/14141\n                            if (!('newVersion' in ev)) {\n                                ev.newVersion = e.newVersion;\n                            }\n\n                            if (!('oldVersion' in ev)) {\n                                ev.oldVersion = e.oldVersion;\n                            }\n\n                            res(ev);\n                        };\n                        request.onerror = e => {\n                            e.preventDefault();\n                            rej(e);\n                        };\n                    });\n                    e.resume = resume;\n                    reject(e);\n                };\n            });\n        },\n\n        cmp: function (param1, param2) {\n            return new Promise(function (resolve, reject) {\n                resolve(indexedDB.cmp(param1, param2)); // May throw\n            });\n        },\n\n        rangeIncludes: function (range, key) {\n            return new Promise(function (resolve, reject) {\n                range = mongoifyKey(range); // May throw\n                if (!range || typeof range !== 'object') {\n                    reject(new TypeError('Bad range supplied'));\n                    return;\n                }\n                key = mongoifyKey(key); // May throw\n                resolve(range.includes(key));\n            });\n        }\n    };\n\n    if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n        module.exports = db;\n    } else if (typeof define === 'function' && define.amd) {\n        define(function () { return db; });\n    } else {\n        local.db = db;\n    }\n}(self));\n"]}